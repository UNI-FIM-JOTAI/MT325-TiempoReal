CCS PCH C Compiler, Version 5.008, 5967               21-oct-14 16:41

               Filename:   D:\IGNACIO\ProgramacionGitHub\MT325-TiempoReal\Sistema\Programa PIC\SistemaPIC18f4550\ComunicacionSerial\ComSerial.lst

               ROM used:   3034 bytes (9%)
                           Largest free fragment is 12288
               RAM used:   181 (9%) at main() level
                           221 (11%) worst case
               Stack used: 6 locations (2 in main + 4 for interrupts)
               Stack size: 31

*
0000:  GOTO   08E2
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   00A8
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   02E8
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVF   04,W
0098:  MOVFF  06,FE0
009C:  MOVFF  05,FD8
00A0:  RETFIE 0
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
*
028E:  TBLRD*+
0290:  MOVF   FF5,F
0292:  BZ    02AE
0294:  MOVFF  FF6,B7
0298:  MOVFF  FF7,B8
029C:  MOVF   FF5,W
029E:  BTFSS  F9E.4
02A0:  BRA    029E
02A2:  MOVWF  FAD
02A4:  MOVFF  B7,FF6
02A8:  MOVFF  B8,FF7
02AC:  BRA    028E
02AE:  RETURN 0
*
0308:  DATA 52,65
030A:  DATA 63,69
030C:  DATA 62,69
030E:  DATA 64,6F
0310:  DATA 00,00
0312:  DATA 50,72
0314:  DATA 6F,63
0316:  DATA 65,73
0318:  DATA 6F,20
031A:  DATA 25,69
031C:  DATA 20,63
031E:  DATA 61,72
0320:  DATA 67,61
0322:  DATA 64,6F
0324:  DATA 2E,20
0326:  DATA 2A,00
0328:  DATA 50,72
032A:  DATA 6F,63
032C:  DATA 65,73
032E:  DATA 6F,20
0330:  DATA 25,69
0332:  DATA 20,64
0334:  DATA 65,73
0336:  DATA 63,61
0338:  DATA 72,67
033A:  DATA 61,64
033C:  DATA 6F,2E
033E:  DATA 20,2A
0340:  DATA 00,00
0342:  DATA 43,6F
0344:  DATA 6E,65
0346:  DATA 63,74
0348:  DATA 61,64
034A:  DATA 6F,2E
034C:  DATA 2E,2E
034E:  DATA 2E,2E
0350:  DATA 2E,2E
0352:  DATA 2E,2E
0354:  DATA 2E,2E
0356:  DATA 2E,2E
0358:  DATA 2A,00
035A:  CLRF   xD7
035C:  CLRF   xD8
035E:  MOVLW  01
0360:  MOVWF  xD9
0362:  CLRF   FDA
0364:  CLRF   FD9
0366:  CLRF   xDC
0368:  MOVLW  CF
036A:  MOVWF  xDB
036C:  CLRF   FEA
036E:  MOVLW  D3
0370:  MOVWF  FE9
0372:  MOVFF  DC,FE2
0376:  MOVFF  DB,FE1
037A:  MOVFF  D9,DA
037E:  BCF    FD8.0
0380:  MOVF   FE5,W
0382:  MULWF  FEE
0384:  MOVF   FF3,W
0386:  ADDWFC xD7,F
0388:  MOVF   FF4,W
038A:  ADDWFC xD8,F
038C:  DECFSZ xDA,F
038E:  BRA    037E
0390:  MOVFF  D7,FDE
0394:  MOVFF  D8,D7
0398:  CLRF   xD8
039A:  BTFSC  FD8.0
039C:  INCF   xD8,F
039E:  INCF   xDB,F
03A0:  BTFSC  FD8.2
03A2:  INCF   xDC,F
03A4:  INCF   xD9,F
03A6:  MOVF   xD9,W
03A8:  SUBLW  05
03AA:  BNZ   036C
03AC:  RETURN 0
*
0588:  TBLRD*+
058A:  MOVFF  FF6,C8
058E:  MOVFF  FF7,C9
0592:  MOVF   FF5,W
0594:  BTFSS  F9E.4
0596:  BRA    0594
0598:  MOVWF  FAD
059A:  MOVFF  C8,FF6
059E:  MOVFF  C9,FF7
05A2:  DECFSZ xC7,F
05A4:  BRA    0588
05A6:  RETURN 0
05A8:  MOVF   xCE,W
05AA:  CLRF   01
05AC:  SUBWF  xCD,W
05AE:  BC    05B6
05B0:  MOVFF  CD,00
05B4:  BRA    05CE
05B6:  CLRF   00
05B8:  MOVLW  08
05BA:  MOVWF  xCF
05BC:  RLCF   xCD,F
05BE:  RLCF   00,F
05C0:  MOVF   xCE,W
05C2:  SUBWF  00,W
05C4:  BTFSC  FD8.0
05C6:  MOVWF  00
05C8:  RLCF   01,F
05CA:  DECFSZ xCF,F
05CC:  BRA    05BC
05CE:  RETURN 0
05D0:  MOVLW  20
05D2:  BTFSS  xC8.4
05D4:  MOVLW  30
05D6:  MOVWF  xC9
05D8:  MOVFF  C7,00
05DC:  BTFSS  xC7.7
05DE:  BRA    05F0
05E0:  COMF   00,F
05E2:  INCF   00,F
05E4:  MOVFF  00,C7
05E8:  MOVLW  2D
05EA:  MOVWF  xC9
05EC:  BSF    xC8.7
05EE:  BSF    xC8.0
05F0:  MOVF   01,W
05F2:  MOVFF  C7,CD
05F6:  MOVLW  64
05F8:  MOVWF  xCE
05FA:  RCALL  05A8
05FC:  MOVFF  00,C7
0600:  MOVLW  30
0602:  ADDWF  01,W
0604:  MOVWF  xCA
0606:  MOVFF  C7,CD
060A:  MOVLW  0A
060C:  MOVWF  xCE
060E:  RCALL  05A8
0610:  MOVLW  30
0612:  ADDWF  00,W
0614:  MOVWF  xCC
0616:  MOVLW  30
0618:  ADDWF  01,W
061A:  MOVWF  xCB
061C:  MOVFF  C9,00
0620:  MOVLW  30
0622:  SUBWF  xCA,W
0624:  BZ    062E
0626:  BSF    xC8.1
0628:  BTFSC  xC8.7
062A:  BSF    xC8.2
062C:  BRA    0652
062E:  MOVFF  C9,CA
0632:  MOVLW  20
0634:  MOVWF  xC9
0636:  MOVLW  30
0638:  SUBWF  xCB,W
063A:  BZ    0644
063C:  BSF    xC8.0
063E:  BTFSC  xC8.7
0640:  BSF    xC8.1
0642:  BRA    0652
0644:  BTFSS  FD8.2
0646:  BSF    xC8.0
0648:  BNZ   0652
064A:  MOVFF  CA,CB
064E:  MOVLW  20
0650:  MOVWF  xCA
0652:  BTFSC  xC8.2
0654:  BRA    0660
0656:  BTFSC  xC8.1
0658:  BRA    0668
065A:  BTFSC  xC8.0
065C:  BRA    0670
065E:  BRA    0678
0660:  MOVF   xC9,W
0662:  BTFSS  F9E.4
0664:  BRA    0662
0666:  MOVWF  FAD
0668:  MOVF   xCA,W
066A:  BTFSS  F9E.4
066C:  BRA    066A
066E:  MOVWF  FAD
0670:  MOVF   xCB,W
0672:  BTFSS  F9E.4
0674:  BRA    0672
0676:  MOVWF  FAD
0678:  MOVF   xCC,W
067A:  BTFSS  F9E.4
067C:  BRA    067A
067E:  MOVWF  FAD
0680:  RETURN 0
*
07BC:  DATA 45,73
07BE:  DATA 70,65
07C0:  DATA 72,61
07C2:  DATA 6E,64
07C4:  DATA 6F,20
07C6:  DATA 63,6F
07C8:  DATA 6E,65
07CA:  DATA 78,69
07CC:  DATA F3,6E
07CE:  DATA 2E,2E
07D0:  DATA 2A,00
....................  
.................... #list 
....................  
....................  
.................... #use delay(clock=10000000) 
.................... #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7,bits=8,parity=N) 
.................... #fuses HS,NOPROTECT,NOWDT,NOLVP,CPUDIV1,nomclr 
.................... #define Tiempo 200 
....................  
.................... #use FAST_IO(A)  
.................... #use FAST_IO(B) 
.................... #use FAST_IO(D) 
....................  
.................... #byte T0CON=0xFD5 
.................... #byte wreg=0xFE8 
.................... #byte TOSU=0xFFF 
.................... #byte TOSH=0xFFE 
.................... #byte TOSL=0xFFD 
....................  
.................... int np=0; 
.................... int colap[6]; 
.................... int m; 
.................... int8 i,j,j1,j2,j3,j4; 
....................  
.................... int c1,c2; 
.................... int k1,k2,k3,k4,k5,k6; 
.................... int l1,l2,l3,l4,l5,l6; 
....................  
.................... char proceso; 
....................  
.................... int const lenbuff=10; 
.................... int32 valor=0; 
.................... int32 valor2=0; 
.................... int32 val1,val2,val3,val4,val5; 
.................... int16 quantum=65048; 
....................  
....................  
.................... int   xbuff=0x00; 
.................... char  cbuff[lenbuff]; 
.................... char  rcvchar=0x00; 
.................... char  comando; 
.................... int1  flagcmd=0; 
....................  
....................  
.................... struct pcb{ 
.................... int32 di; 
.................... int32 df;  
.................... int32 da; 
.................... int estado;  
.................... int wreg;  
.................... int status; 
.................... int bsr; 
.................... int id; 
.................... } vpcb[5]; 
....................  
.................... void activar_timer() 
.................... { 
....................    set_timer0(quantum); 
*
07B0:  MOVFF  51,FD7
07B4:  MOVFF  50,FD6
....................    enable_interrupts(INT_TIMER0); 
07B8:  BSF    FF2.5
07BA:  RETURN 0
.................... } 
....................  
.................... void desactivar_timer() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
00A2:  BCF    FF2.5
00A4:  GOTO   00AC (RETURN)
.................... } 
....................  
.................... void addcbuff(char c); 
.................... void mostrar_procesos(); 
.................... void descargar_proceso(int idp); 
.................... void Config_TMR0(); 
....................  
....................  
.................... #INT_TIMER0 
.................... void inter_quantum() 
00A8:  CLRF   xB7
.................... {  int i=0; 
....................    desactivar_timer(); 
00AA:  BRA    00A2
....................    vpcb[colap[0]].wreg=wreg; 
00AC:  MOVF   18,W
00AE:  MULLW  11
00B0:  MOVF   FF3,W
00B2:  CLRF   xB9
00B4:  MOVWF  xB8
00B6:  MOVLW  0D
00B8:  ADDWF  xB8,W
00BA:  MOVWF  01
00BC:  MOVLW  00
00BE:  ADDWFC xB9,W
00C0:  MOVWF  03
00C2:  MOVF   01,W
00C4:  ADDLW  60
00C6:  MOVWF  FE9
00C8:  MOVLW  00
00CA:  ADDWFC 03,W
00CC:  MOVWF  FEA
00CE:  MOVFF  FE8,FEF
....................    vpcb[colap[0]].da=(int32)TOSL; 
00D2:  MOVF   18,W
00D4:  MULLW  11
00D6:  MOVF   FF3,W
00D8:  CLRF   xB9
00DA:  MOVWF  xB8
00DC:  MOVLW  08
00DE:  ADDWF  xB8,W
00E0:  MOVWF  01
00E2:  MOVLW  00
00E4:  ADDWFC xB9,W
00E6:  MOVWF  03
00E8:  MOVF   01,W
00EA:  ADDLW  60
00EC:  MOVWF  FE9
00EE:  MOVLW  00
00F0:  ADDWFC 03,W
00F2:  MOVWF  FEA
00F4:  CLRF   01
00F6:  CLRF   02
00F8:  CLRF   03
00FA:  MOVFF  FFD,FEF
00FE:  MOVFF  01,FEC
0102:  MOVFF  02,FEC
0106:  MOVFF  03,FEC
....................    vpcb[colap[0]].da=vpcb[colap[0]].da|((int32)TOSH<<8); 
010A:  MOVF   18,W
010C:  MULLW  11
010E:  MOVF   FF3,W
0110:  CLRF   xB9
0112:  MOVWF  xB8
0114:  MOVLW  08
0116:  ADDWF  xB8,W
0118:  MOVWF  01
011A:  MOVLW  00
011C:  ADDWFC xB9,W
011E:  MOVWF  03
0120:  MOVF   01,W
0122:  ADDLW  60
0124:  MOVWF  01
0126:  MOVLW  00
0128:  ADDWFC 03,F
012A:  MOVFF  01,B8
012E:  MOVFF  03,B9
0132:  MOVF   18,W
0134:  MULLW  11
0136:  MOVF   FF3,W
0138:  CLRF   xBB
013A:  MOVWF  xBA
013C:  MOVLW  08
013E:  ADDWF  xBA,W
0140:  MOVWF  01
0142:  MOVLW  00
0144:  ADDWFC xBB,W
0146:  MOVWF  03
0148:  MOVF   01,W
014A:  ADDLW  60
014C:  MOVWF  FE9
014E:  MOVLW  00
0150:  ADDWFC 03,W
0152:  MOVWF  FEA
0154:  MOVFF  FEF,BA
0158:  MOVFF  FEC,BB
015C:  MOVFF  FEC,BC
0160:  MOVFF  FEC,BD
0164:  CLRF   xC0
0166:  CLRF   xBF
0168:  CLRF   00
016A:  MOVF   00,W
016C:  IORWF  xBA,W
016E:  MOVWF  00
0170:  MOVF   FFE,W
0172:  IORWF  xBB,W
0174:  MOVWF  01
0176:  MOVF   xBF,W
0178:  IORWF  xBC,W
017A:  MOVWF  02
017C:  MOVF   xC0,W
017E:  IORWF  xBD,W
0180:  MOVFF  B9,FEA
0184:  MOVFF  B8,FE9
0188:  MOVFF  00,FEF
018C:  MOVFF  01,FEC
0190:  MOVFF  02,FEC
0194:  MOVWF  FEC
....................    vpcb[colap[0]].da=vpcb[colap[0]].da|((int32)TOSU<<16); 
0196:  MOVF   18,W
0198:  MULLW  11
019A:  MOVF   FF3,W
019C:  CLRF   xB9
019E:  MOVWF  xB8
01A0:  MOVLW  08
01A2:  ADDWF  xB8,W
01A4:  MOVWF  01
01A6:  MOVLW  00
01A8:  ADDWFC xB9,W
01AA:  MOVWF  03
01AC:  MOVF   01,W
01AE:  ADDLW  60
01B0:  MOVWF  01
01B2:  MOVLW  00
01B4:  ADDWFC 03,F
01B6:  MOVFF  01,B8
01BA:  MOVFF  03,B9
01BE:  MOVF   18,W
01C0:  MULLW  11
01C2:  MOVF   FF3,W
01C4:  CLRF   xBB
01C6:  MOVWF  xBA
01C8:  MOVLW  08
01CA:  ADDWF  xBA,W
01CC:  MOVWF  01
01CE:  MOVLW  00
01D0:  ADDWFC xBB,W
01D2:  MOVWF  03
01D4:  MOVF   01,W
01D6:  ADDLW  60
01D8:  MOVWF  FE9
01DA:  MOVLW  00
01DC:  ADDWFC 03,W
01DE:  MOVWF  FEA
01E0:  MOVFF  FEF,BA
01E4:  MOVFF  FEC,BB
01E8:  MOVFF  FEC,BC
01EC:  MOVFF  FEC,BD
01F0:  CLRF   xBF
01F2:  CLRF   00
01F4:  CLRF   01
01F6:  MOVF   00,W
01F8:  IORWF  xBA,W
01FA:  MOVWF  00
01FC:  MOVF   01,W
01FE:  IORWF  xBB,W
0200:  MOVWF  01
0202:  MOVF   FFF,W
0204:  IORWF  xBC,W
0206:  MOVWF  02
0208:  MOVF   xBF,W
020A:  IORWF  xBD,W
020C:  MOVFF  B9,FEA
0210:  MOVFF  B8,FE9
0214:  MOVFF  00,FEF
0218:  MOVFF  01,FEC
021C:  MOVFF  02,FEC
0220:  MOVWF  FEC
....................    output_toggle(PIN_D6); 
0222:  BTG    F8C.6
....................    if(np>1) 
0224:  MOVF   17,W
0226:  SUBLW  01
0228:  BC    0280
....................    {  m=colap[0]; 
022A:  MOVFF  18,1E
....................       for(i=0;i<np-1;i++) 
022E:  CLRF   xB7
0230:  MOVLW  01
0232:  SUBWF  17,W
0234:  SUBWF  xB7,W
0236:  BC    026C
....................       {colap[i]=colap[i+1]; 
0238:  CLRF   03
023A:  MOVF   xB7,W
023C:  ADDLW  18
023E:  MOVWF  01
0240:  MOVLW  00
0242:  ADDWFC 03,F
0244:  MOVFF  03,B9
0248:  MOVLW  01
024A:  ADDWF  xB7,W
024C:  CLRF   03
024E:  ADDLW  18
0250:  MOVWF  FE9
0252:  MOVLW  00
0254:  ADDWFC 03,W
0256:  MOVWF  FEA
0258:  MOVFF  FEF,BA
025C:  MOVFF  B9,FEA
0260:  MOVFF  01,FE9
0264:  MOVFF  BA,FEF
0268:  INCF   xB7,F
026A:  BRA    0230
....................       } 
....................       colap[np-1]=m; 
026C:  MOVLW  01
026E:  SUBWF  17,W
0270:  CLRF   03
0272:  ADDLW  18
0274:  MOVWF  FE9
0276:  MOVLW  00
0278:  ADDWFC 03,W
027A:  MOVWF  FEA
027C:  MOVFF  1E,FEF
....................    } 
....................     
....................    TOSL=00; 
0280:  CLRF   FFD
....................    TOSH=40; 
0282:  MOVLW  28
0284:  MOVWF  FFE
....................    TOSU=00; 
0286:  CLRF   FFF
0288:  BCF    FF2.2
028A:  GOTO   0060
.................... }  
....................  
....................  
.................... void inte_Init()  // interrupcion de puerto serial 
.................... { 
....................    enable_interrupts(GLOBAL); 
*
088E:  MOVLW  C0
0890:  IORWF  FF2,F
....................    enable_interrupts(INT_RDA); 
0892:  BSF    F9D.5
0894:  GOTO   08BC (RETURN)
.................... } 
....................  
....................  
.................... #INT_RDA 
.................... void serial_isr() 
.................... { 
....................    printf("Recibido");     // se envia por Serial una palabra para verificar interrupcion 
*
02E8:  MOVLW  08
02EA:  MOVWF  FF6
02EC:  MOVLW  03
02EE:  MOVWF  FF7
02F0:  RCALL  028E
....................    rcvchar = 0x00; 
02F2:  CLRF   5D
....................    rcvchar = getc();    // se recibe el caracter enviado por la computadora 
02F4:  BTFSS  F9E.5
02F6:  BRA    02F4
02F8:  MOVFF  FAE,5D
....................    addcbuff(rcvchar);   // guarda el caracter en un buffer 
02FC:  MOVFF  5D,B7
0300:  BRA    02B0
0302:  BCF    F9E.5
0304:  GOTO   0060
.................... } 
....................  
.................... void addcbuff(char c)    
.................... { 
....................    switch(c) 
*
02B0:  MOVF   xB7,W
02B2:  XORLW  2A
02B4:  BZ    02B8
02B6:  BRA    02D0
....................    { 
....................       case '*':                  // en caso de recibir *, levanta el flag para saber que se termino de enviar un comando. 
....................          cbuff[xbuff++] = c; 
02B8:  MOVF   52,W
02BA:  INCF   52,F
02BC:  CLRF   03
02BE:  ADDLW  53
02C0:  MOVWF  FE9
02C2:  MOVLW  00
02C4:  ADDWFC 03,W
02C6:  MOVWF  FEA
02C8:  MOVFF  B7,FEF
....................          flagcmd = 1; 
02CC:  BSF    5F.0
....................       break; 
02CE:  BRA    02E4
....................       default: 
....................          cbuff[xbuff++] = c; 
02D0:  MOVF   52,W
02D2:  INCF   52,F
02D4:  CLRF   03
02D6:  ADDLW  53
02D8:  MOVWF  FE9
02DA:  MOVLW  00
02DC:  ADDWFC 03,W
02DE:  MOVWF  FEA
02E0:  MOVFF  B7,FEF
....................    } 
02E4:  GOTO   0302 (RETURN)
.................... } 
....................  
.................... void inicbuff(void)           // inicializa el buffer, limpiandolo 
.................... { 
....................    int i; 
....................    for (i=0; i<lenbuff;i++)       
*
03AE:  CLRF   xCF
03B0:  MOVF   xCF,W
03B2:  SUBLW  09
03B4:  BNC   03CA
....................    { 
....................       cbuff[i] = 0x00; 
03B6:  CLRF   03
03B8:  MOVF   xCF,W
03BA:  ADDLW  53
03BC:  MOVWF  FE9
03BE:  MOVLW  00
03C0:  ADDWFC 03,W
03C2:  MOVWF  FEA
03C4:  CLRF   FEF
03C6:  INCF   xCF,F
03C8:  BRA    03B0
....................    } 
....................    xbuff=0x00; 
03CA:  CLRF   52
03CC:  GOTO   0566 (RETURN)
.................... } 
....................  
.................... void procesa_cmd(void){             // procesa el ultimo comando guardado, un comando esta comprendido entre $ hasta *  
03D0:  CLRF   xC4
....................   
....................    int i, j=0;                       
....................    char salida[lenbuff];            // Argumento de comando (si lo tiene) 
....................    disable_interrupts(int_rda);      
03D2:  BCF    F9D.5
....................    flagcmd=0;                       // Desactivo flag de comando pendiente. 
03D4:  BCF    5F.0
....................    for (i=0;i<xbuff;i++) 
03D6:  CLRF   xC3
03D8:  MOVF   52,W
03DA:  SUBWF  xC3,W
03DC:  BTFSC  FD8.0
03DE:  BRA    0564
....................    { 
....................       if (cbuff[i] == '$'){         // verifica que tenga '$' 
03E0:  CLRF   03
03E2:  MOVF   xC3,W
03E4:  ADDLW  53
03E6:  MOVWF  FE9
03E8:  MOVLW  00
03EA:  ADDWFC 03,W
03EC:  MOVWF  FEA
03EE:  MOVF   FEF,W
03F0:  SUBLW  24
03F2:  BTFSS  FD8.2
03F4:  BRA    0560
....................          while((cbuff[i] != '*') & (i<xbuff))   // hasta que encuentre * 
03F6:  CLRF   03
03F8:  MOVF   xC3,W
03FA:  ADDLW  53
03FC:  MOVWF  FE9
03FE:  MOVLW  00
0400:  ADDWFC 03,W
0402:  MOVWF  FEA
0404:  MOVF   FEF,W
0406:  SUBLW  2A
0408:  BNZ   040E
040A:  MOVLW  00
040C:  BRA    0410
040E:  MOVLW  01
0410:  MOVWF  xCF
0412:  MOVF   52,W
0414:  SUBWF  xC3,W
0416:  BNC   041C
0418:  MOVLW  00
041A:  BRA    041E
041C:  MOVLW  01
041E:  ANDWF  xCF,W
0420:  BZ    045A
....................          { 
....................             salida[j++]=cbuff[i++]; 
0422:  MOVF   xC4,W
0424:  INCF   xC4,F
0426:  CLRF   03
0428:  ADDLW  C5
042A:  MOVWF  01
042C:  MOVLW  00
042E:  ADDWFC 03,F
0430:  MOVFF  01,CF
0434:  MOVFF  03,D0
0438:  MOVF   xC3,W
043A:  INCF   xC3,F
043C:  CLRF   03
043E:  ADDLW  53
0440:  MOVWF  FE9
0442:  MOVLW  00
0444:  ADDWFC 03,W
0446:  MOVWF  FEA
0448:  MOVFF  FEF,D1
044C:  MOVFF  D0,FEA
0450:  MOVFF  01,FE9
0454:  MOVFF  D1,FEF
0458:  BRA    03F6
....................          } 
....................          comando = salida[1]; 
045A:  MOVFF  C6,5E
....................          valor2 = salida[2] -'0' + 1; 
045E:  MOVLW  30
0460:  SUBWF  xC7,W
0462:  ADDLW  01
0464:  MOVWF  38
0466:  CLRF   39
0468:  CLRF   3A
046A:  CLRF   3B
....................          val1 = salida[2] - '0'; 
046C:  MOVLW  30
046E:  SUBWF  xC7,W
0470:  MOVWF  3C
0472:  CLRF   3D
0474:  CLRF   3E
0476:  CLRF   3F
....................          val1 = val1; 
....................          val2 = salida[3] - '0'; 
0478:  MOVLW  30
047A:  SUBWF  xC8,W
047C:  MOVWF  40
047E:  CLRF   41
0480:  CLRF   42
0482:  CLRF   43
....................          val2 = val1*10 + val2; 
0484:  MOVFF  3F,D2
0488:  MOVFF  3E,D1
048C:  MOVFF  3D,D0
0490:  MOVFF  3C,CF
0494:  CLRF   xD6
0496:  CLRF   xD5
0498:  CLRF   xD4
049A:  MOVLW  0A
049C:  MOVWF  xD3
049E:  RCALL  035A
04A0:  MOVF   00,W
04A2:  ADDWF  40,F
04A4:  MOVF   01,W
04A6:  ADDWFC 41,F
04A8:  MOVF   02,W
04AA:  ADDWFC 42,F
04AC:  MOVF   03,W
04AE:  ADDWFC 43,F
....................          val3 = salida[4] - '0'; 
04B0:  MOVLW  30
04B2:  SUBWF  xC9,W
04B4:  MOVWF  44
04B6:  CLRF   45
04B8:  CLRF   46
04BA:  CLRF   47
....................          val3 = val2*10 +val3; 
04BC:  MOVFF  43,D2
04C0:  MOVFF  42,D1
04C4:  MOVFF  41,D0
04C8:  MOVFF  40,CF
04CC:  CLRF   xD6
04CE:  CLRF   xD5
04D0:  CLRF   xD4
04D2:  MOVLW  0A
04D4:  MOVWF  xD3
04D6:  RCALL  035A
04D8:  MOVF   00,W
04DA:  ADDWF  44,F
04DC:  MOVF   01,W
04DE:  ADDWFC 45,F
04E0:  MOVF   02,W
04E2:  ADDWFC 46,F
04E4:  MOVF   03,W
04E6:  ADDWFC 47,F
....................          val4 = salida[5] - '0'; 
04E8:  MOVLW  30
04EA:  SUBWF  xCA,W
04EC:  MOVWF  48
04EE:  CLRF   49
04F0:  CLRF   4A
04F2:  CLRF   4B
....................          val4 = val3*10+val4; 
04F4:  MOVFF  47,D2
04F8:  MOVFF  46,D1
04FC:  MOVFF  45,D0
0500:  MOVFF  44,CF
0504:  CLRF   xD6
0506:  CLRF   xD5
0508:  CLRF   xD4
050A:  MOVLW  0A
050C:  MOVWF  xD3
050E:  RCALL  035A
0510:  MOVF   00,W
0512:  ADDWF  48,F
0514:  MOVF   01,W
0516:  ADDWFC 49,F
0518:  MOVF   02,W
051A:  ADDWFC 4A,F
051C:  MOVF   03,W
051E:  ADDWFC 4B,F
....................          val5 = salida[6]-'0'; 
0520:  MOVLW  30
0522:  SUBWF  xCB,W
0524:  MOVWF  4C
0526:  CLRF   4D
0528:  CLRF   4E
052A:  CLRF   4F
....................          valor = val4*10 + val5; 
052C:  MOVFF  4B,D2
0530:  MOVFF  4A,D1
0534:  MOVFF  49,D0
0538:  MOVFF  48,CF
053C:  CLRF   xD6
053E:  CLRF   xD5
0540:  CLRF   xD4
0542:  MOVLW  0A
0544:  MOVWF  xD3
0546:  RCALL  035A
0548:  MOVF   4C,W
054A:  ADDWF  00,W
054C:  MOVWF  34
054E:  MOVF   4D,W
0550:  ADDWFC 01,W
0552:  MOVWF  35
0554:  MOVF   4E,W
0556:  ADDWFC 02,W
0558:  MOVWF  36
055A:  MOVF   4F,W
055C:  ADDWFC 03,W
055E:  MOVWF  37
....................       } 
0560:  INCF   xC3,F
0562:  BRA    03D8
....................    } 
....................    inicbuff();                            // Borro buffer. 
0564:  BRA    03AE
....................    for(i=0;i<lenbuff;i++)                 // Bucle que pone a 0 todos los 
0566:  CLRF   xC3
0568:  MOVF   xC3,W
056A:  SUBLW  09
056C:  BNC   0582
....................    { 
....................       salida[i]=0x00;                     // caracteres en el argumento 
056E:  CLRF   03
0570:  MOVF   xC3,W
0572:  ADDLW  C5
0574:  MOVWF  FE9
0576:  MOVLW  00
0578:  ADDWFC 03,W
057A:  MOVWF  FEA
057C:  CLRF   FEF
057E:  INCF   xC3,F
0580:  BRA    0568
....................    } 
....................    enable_interrupts(int_rda);             
0582:  BSF    F9D.5
0584:  GOTO   4008 (RETURN)
.................... } 
....................  
.................... //PROGRAMA 1: Luces Secuenciales - Bucle Infinito 
....................  
.................... #ORG 0x1000, 0x1100 
.................... void ROML_LedA1() 
.................... { 
....................    set_tris_a(0x00); 
*
1000:  MOVLW  00
1002:  MOVWF  F92
....................    while(TRUE) 
....................    { 
....................       for (j1=0;j1<3;++j1) 
1004:  CLRF   21
1006:  MOVF   21,W
1008:  SUBLW  02
100A:  BNC   1042
....................       { 
....................          IF(j1==0) 
100C:  MOVF   21,F
100E:  BNZ   1014
....................          { 
....................             OUTPUT_BIT(PIN_A0,0); 
1010:  BCF    F89.0
....................             OUTPUT_BIT(PIN_A1,0); 
1012:  BCF    F89.1
....................          } 
....................          IF(j1==1){OUTPUT_BIT(PIN_A0,1);} 
1014:  DECFSZ 21,W
1016:  BRA    101A
1018:  BSF    F89.0
....................          IF(j1==2){OUTPUT_BIT(PIN_A1,1);} 
101A:  MOVF   21,W
101C:  SUBLW  02
101E:  BNZ   1022
1020:  BSF    F89.1
....................          for (k1=1;k1<200;++k1){for (l1=1;l1<200;++l1){}} 
1022:  MOVLW  01
1024:  MOVWF  27
1026:  MOVF   27,W
1028:  SUBLW  C7
102A:  BNC   103E
102C:  MOVLW  01
102E:  MOVWF  2D
1030:  MOVF   2D,W
1032:  SUBLW  C7
1034:  BNC   103A
1036:  INCF   2D,F
1038:  BRA    1030
103A:  INCF   27,F
103C:  BRA    1026
103E:  INCF   21,F
1040:  BRA    1006
....................       } 
1042:  BRA    1004
....................    } 
1044:  RETURN 0
.................... } 
....................  
.................... //PROGRAMA 2: Luces Secuenciales 2 - Bucle Infinito 
....................  
.................... #ORG 0x1102, 0x1200 
.................... void ROML_LedA2() 
.................... { 
....................    set_tris_d(0x00); 
*
1102:  MOVLW  00
1104:  MOVWF  F95
....................    while(TRUE) 
....................    { 
....................       for (j2=0;j2<3;++j2) 
1106:  CLRF   22
1108:  MOVF   22,W
110A:  SUBLW  02
110C:  BNC   1146
....................       { 
....................          IF(j2==0) 
110E:  MOVF   22,F
1110:  BNZ   1116
....................          { 
....................             OUTPUT_BIT(PIN_D2,0); 
1112:  BCF    F8C.2
....................             OUTPUT_BIT(PIN_D3,0); 
1114:  BCF    F8C.3
....................          } 
....................          IF(j2==1) 
1116:  DECFSZ 22,W
1118:  BRA    111C
....................          { 
....................             OUTPUT_BIT(PIN_D2,1); 
111A:  BSF    F8C.2
....................          } 
....................          IF(j2==2) 
111C:  MOVF   22,W
111E:  SUBLW  02
1120:  BNZ   1126
....................          { 
....................             OUTPUT_BIT(PIN_D2,0); 
1122:  BCF    F8C.2
....................             OUTPUT_BIT(PIN_D3,1); 
1124:  BSF    F8C.3
....................          }          
....................          for (k2=1;k2<150;++k2){for (l2=1;l2<200;++l2){}} 
1126:  MOVLW  01
1128:  MOVWF  28
112A:  MOVF   28,W
112C:  SUBLW  95
112E:  BNC   1142
1130:  MOVLW  01
1132:  MOVWF  2E
1134:  MOVF   2E,W
1136:  SUBLW  C7
1138:  BNC   113E
113A:  INCF   2E,F
113C:  BRA    1134
113E:  INCF   28,F
1140:  BRA    112A
1142:  INCF   22,F
1144:  BRA    1108
....................       } 
1146:  BRA    1106
....................    } 
1148:  RETURN 0
.................... } 
....................  
.................... //PROGRAMA 5: Luces Secuenciales C - Finito 
....................  
.................... #ORG 0x1202, 0x1300 
.................... void voidTask_LedC1(){ 
.................... while(TRUE){ 
....................    while(TRUE) 
....................    { 
....................       for (c1=0;c1<5;c1++) 
*
1202:  CLRF   25
1204:  MOVF   25,W
1206:  SUBLW  04
1208:  BNC   124E
....................       { 
....................          for (j3=0;j3<3;++j3) 
120A:  CLRF   23
120C:  MOVF   23,W
120E:  SUBLW  02
1210:  BNC   124A
....................          { 
....................             IF(j3==0) 
1212:  MOVF   23,F
1214:  BNZ   121A
....................             { 
....................                OUTPUT_BIT(PIN_D0,0); 
1216:  BCF    F8C.0
....................                OUTPUT_BIT(PIN_D1,0); 
1218:  BCF    F8C.1
....................             } 
....................             IF(j3==1) 
121A:  DECFSZ 23,W
121C:  BRA    1220
....................             { 
....................                OUTPUT_BIT(PIN_D0,1); 
121E:  BSF    F8C.0
....................             } 
....................             IF(j3==2) 
1220:  MOVF   23,W
1222:  SUBLW  02
1224:  BNZ   122A
....................             { 
....................                OUTPUT_BIT(PIN_D0,0); 
1226:  BCF    F8C.0
....................                OUTPUT_BIT(PIN_D1,1); 
1228:  BSF    F8C.1
....................             }          
....................             for (k5=1;k5<200;++k5){for (l5=1;l5<200;++l5){}} 
122A:  MOVLW  01
122C:  MOVWF  2B
122E:  MOVF   2B,W
1230:  SUBLW  C7
1232:  BNC   1246
1234:  MOVLW  01
1236:  MOVWF  31
1238:  MOVF   31,W
123A:  SUBLW  C7
123C:  BNC   1242
123E:  INCF   31,F
1240:  BRA    1238
1242:  INCF   2B,F
1244:  BRA    122E
1246:  INCF   23,F
1248:  BRA    120C
....................          } 
124A:  INCF   25,F
124C:  BRA    1204
....................       } 
....................       comando='D'; 
124E:  MOVLW  44
1250:  MOVWF  5E
....................       valor2=3; 
1252:  CLRF   3B
1254:  CLRF   3A
1256:  CLRF   39
1258:  MOVLW  03
125A:  MOVWF  38
125C:  BRA    1202
....................    } 
125E:  BRA    1202
.................... } 
1260:  RETURN 0
.................... } 
....................  
.................... //PROGRAMA 6: Luces Secuenciales C2 - Finito 
....................  
.................... #ORG 0x1302, 0x1400 
.................... void voidTask_LedC2(){ 
....................    while(TRUE){ 
....................       while(TRUE) 
....................       { 
....................          for (c2=0;c2<5;c2++) 
*
1302:  CLRF   26
1304:  MOVF   26,W
1306:  SUBLW  04
1308:  BNC   134E
....................          { 
....................             for (j4=0;j4<3;++j4) 
130A:  CLRF   24
130C:  MOVF   24,W
130E:  SUBLW  02
1310:  BNC   134A
....................             { 
....................                IF(j4==0) 
1312:  MOVF   24,F
1314:  BNZ   131A
....................                { 
....................                   OUTPUT_BIT(PIN_D4,0); 
1316:  BCF    F8C.4
....................                   OUTPUT_BIT(PIN_D5,0); 
1318:  BCF    F8C.5
....................                } 
....................                IF(j4==1) 
131A:  DECFSZ 24,W
131C:  BRA    1320
....................                { 
....................                   OUTPUT_BIT(PIN_D4,1); 
131E:  BSF    F8C.4
....................                } 
....................                IF(j4==2) 
1320:  MOVF   24,W
1322:  SUBLW  02
1324:  BNZ   132A
....................                { 
....................                   OUTPUT_BIT(PIN_D4,0); 
1326:  BCF    F8C.4
....................                   OUTPUT_BIT(PIN_D5,1); 
1328:  BSF    F8C.5
....................                }          
....................                for (k6=1;k6<200;++k6){for (l6=1;l6<200;++l6){}} 
132A:  MOVLW  01
132C:  MOVWF  2C
132E:  MOVF   2C,W
1330:  SUBLW  C7
1332:  BNC   1346
1334:  MOVLW  01
1336:  MOVWF  32
1338:  MOVF   32,W
133A:  SUBLW  C7
133C:  BNC   1342
133E:  INCF   32,F
1340:  BRA    1338
1342:  INCF   2C,F
1344:  BRA    132E
1346:  INCF   24,F
1348:  BRA    130C
....................             } 
134A:  INCF   26,F
134C:  BRA    1304
....................          } 
....................          comando='D'; 
134E:  MOVLW  44
1350:  MOVWF  5E
....................          valor2=4; 
1352:  CLRF   3B
1354:  CLRF   3A
1356:  CLRF   39
1358:  MOVLW  04
135A:  MOVWF  38
135C:  BRA    1302
....................       } 
135E:  BRA    1302
....................    } 
1360:  RETURN 0
.................... } 
....................  
.................... void cargar_proceso(int idp) 
.................... { 
....................     colap[np]=idp-1; 
*
0682:  CLRF   03
0684:  MOVF   17,W
0686:  ADDLW  18
0688:  MOVWF  FE9
068A:  MOVLW  00
068C:  ADDWFC 03,W
068E:  MOVWF  FEA
0690:  MOVLW  01
0692:  SUBWF  xC3,W
0694:  MOVWF  FEF
....................     vpcb[idp-1].estado=1; 
0696:  MOVLW  01
0698:  SUBWF  xC3,W
069A:  MULLW  11
069C:  MOVF   FF3,W
069E:  CLRF   xC5
06A0:  MOVWF  xC4
06A2:  MOVLW  0C
06A4:  ADDWF  xC4,W
06A6:  MOVWF  01
06A8:  MOVLW  00
06AA:  ADDWFC xC5,W
06AC:  MOVWF  03
06AE:  MOVF   01,W
06B0:  ADDLW  60
06B2:  MOVWF  FE9
06B4:  MOVLW  00
06B6:  ADDWFC 03,W
06B8:  MOVWF  FEA
06BA:  MOVLW  01
06BC:  MOVWF  FEF
....................     printf("Proceso %i cargado. *",idp); 
06BE:  MOVLW  12
06C0:  MOVWF  FF6
06C2:  MOVLW  03
06C4:  MOVWF  FF7
06C6:  MOVLW  08
06C8:  MOVWF  xC7
06CA:  RCALL  0588
06CC:  MOVFF  C3,C7
06D0:  MOVLW  18
06D2:  MOVWF  xC8
06D4:  RCALL  05D0
06D6:  MOVLW  1C
06D8:  MOVWF  FF6
06DA:  MOVLW  03
06DC:  MOVWF  FF7
06DE:  MOVLW  0B
06E0:  MOVWF  xC7
06E2:  RCALL  0588
....................     proceso=10; 
06E4:  MOVLW  0A
06E6:  MOVWF  33
....................     np++; 
06E8:  INCF   17,F
06EA:  GOTO   402E (RETURN)
.................... } 
....................  
.................... void descargar_proceso(int idp) 
.................... { 
....................    int s,d,f; 
....................    for(s=0;s<np;s++) 
06EE:  CLRF   xC4
06F0:  MOVF   17,W
06F2:  SUBWF  xC4,W
06F4:  BC    0718
....................       {if(colap[s]==idp-1) 
06F6:  CLRF   03
06F8:  MOVF   xC4,W
06FA:  ADDLW  18
06FC:  MOVWF  FE9
06FE:  MOVLW  00
0700:  ADDWFC 03,W
0702:  MOVWF  FEA
0704:  MOVFF  FEF,C7
0708:  MOVLW  01
070A:  SUBWF  xC3,W
070C:  SUBWF  xC7,W
070E:  BNZ   0714
....................          {d=s;} 
0710:  MOVFF  C4,C5
0714:  INCF   xC4,F
0716:  BRA    06F0
....................       } 
....................    f=np-1; 
0718:  MOVLW  01
071A:  SUBWF  17,W
071C:  MOVWF  xC6
....................    for(s=d;s<f;s++) 
071E:  MOVFF  C5,C4
0722:  MOVF   xC6,W
0724:  SUBWF  xC4,W
0726:  BC    075C
....................       {colap[s]=colap[s+1]; 
0728:  CLRF   03
072A:  MOVF   xC4,W
072C:  ADDLW  18
072E:  MOVWF  01
0730:  MOVLW  00
0732:  ADDWFC 03,F
0734:  MOVFF  03,C8
0738:  MOVLW  01
073A:  ADDWF  xC4,W
073C:  CLRF   03
073E:  ADDLW  18
0740:  MOVWF  FE9
0742:  MOVLW  00
0744:  ADDWFC 03,W
0746:  MOVWF  FEA
0748:  MOVFF  FEF,C9
074C:  MOVFF  C8,FEA
0750:  MOVFF  01,FE9
0754:  MOVFF  C9,FEF
0758:  INCF   xC4,F
075A:  BRA    0722
....................       } 
....................    np--;    
075C:  DECF   17,F
....................    vpcb[idp-1].estado=0; 
075E:  MOVLW  01
0760:  SUBWF  xC3,W
0762:  MULLW  11
0764:  MOVF   FF3,W
0766:  CLRF   xC8
0768:  MOVWF  xC7
076A:  MOVLW  0C
076C:  ADDWF  xC7,W
076E:  MOVWF  01
0770:  MOVLW  00
0772:  ADDWFC xC8,W
0774:  MOVWF  03
0776:  MOVF   01,W
0778:  ADDLW  60
077A:  MOVWF  FE9
077C:  MOVLW  00
077E:  ADDWFC 03,W
0780:  MOVWF  FEA
0782:  CLRF   FEF
....................    proceso=0; 
0784:  CLRF   33
....................    printf("Proceso %i descargado. *",idp); 
0786:  MOVLW  28
0788:  MOVWF  FF6
078A:  MOVLW  03
078C:  MOVWF  FF7
078E:  MOVLW  08
0790:  MOVWF  xC7
0792:  RCALL  0588
0794:  MOVFF  C3,C7
0798:  MOVLW  18
079A:  MOVWF  xC8
079C:  RCALL  05D0
079E:  MOVLW  32
07A0:  MOVWF  FF6
07A2:  MOVLW  03
07A4:  MOVWF  FF7
07A6:  MOVLW  0E
07A8:  MOVWF  xC7
07AA:  RCALL  0588
07AC:  GOTO   404A (RETURN)
.................... } 
....................  
.................... void Port_Init() 
.................... { 
....................    set_tris_b(0x00); 
*
07D2:  MOVLW  00
07D4:  MOVWF  F93
....................    set_tris_d(0x00); 
07D6:  MOVWF  F95
....................    set_tris_a(0x00); 
07D8:  MOVWF  F92
....................    output_b(0x00); 
07DA:  CLRF   F8A
....................    output_d(0x00); 
07DC:  CLRF   F8C
....................    output_a(0x00); 
07DE:  CLRF   F89
07E0:  GOTO   08B8 (RETURN)
.................... } 
....................  
.................... void Config_TMR0() 
.................... { 
....................    T0CON=0b10000111; 
*
0898:  MOVLW  87
089A:  MOVWF  FD5
089C:  GOTO   08BE (RETURN)
....................  
.................... } 
....................  
.................... void Procesos_Init() 
.................... { 
....................    vpcb[0].di=0x1000; 
*
07E4:  CLRF   x63
07E6:  CLRF   x62
07E8:  MOVLW  10
07EA:  MOVWF  x61
07EC:  CLRF   x60
....................    vpcb[0].da=0x1000;    
07EE:  CLRF   x6B
07F0:  CLRF   x6A
07F2:  MOVWF  x69
07F4:  CLRF   x68
....................    vpcb[0].df=0x1100; 
07F6:  CLRF   x67
07F8:  CLRF   x66
07FA:  MOVLW  11
07FC:  MOVWF  x65
07FE:  CLRF   x64
....................    vpcb[1].di=0x1102; 
0800:  CLRF   x74
0802:  CLRF   x73
0804:  MOVWF  x72
0806:  MOVLW  02
0808:  MOVWF  x71
....................    vpcb[1].da=0x1102; 
080A:  CLRF   x7C
080C:  CLRF   x7B
080E:  MOVLW  11
0810:  MOVWF  x7A
0812:  MOVLW  02
0814:  MOVWF  x79
....................    vpcb[1].df=0x1200; 
0816:  CLRF   x78
0818:  CLRF   x77
081A:  MOVLW  12
081C:  MOVWF  x76
081E:  CLRF   x75
....................    vpcb[2].di=0x1202; 
0820:  CLRF   x85
0822:  CLRF   x84
0824:  MOVWF  x83
0826:  MOVLW  02
0828:  MOVWF  x82
....................    vpcb[2].da=0x1202; 
082A:  CLRF   x8D
082C:  CLRF   x8C
082E:  MOVLW  12
0830:  MOVWF  x8B
0832:  MOVLW  02
0834:  MOVWF  x8A
....................    vpcb[2].df=0x1300; 
0836:  CLRF   x89
0838:  CLRF   x88
083A:  MOVLW  13
083C:  MOVWF  x87
083E:  CLRF   x86
....................    vpcb[3].di=0x1302; 
0840:  CLRF   x96
0842:  CLRF   x95
0844:  MOVWF  x94
0846:  MOVLW  02
0848:  MOVWF  x93
....................    vpcb[3].da=0x1302; 
084A:  CLRF   x9E
084C:  CLRF   x9D
084E:  MOVLW  13
0850:  MOVWF  x9C
0852:  MOVLW  02
0854:  MOVWF  x9B
....................    vpcb[3].df=0x1400; 
0856:  CLRF   x9A
0858:  CLRF   x99
085A:  MOVLW  14
085C:  MOVWF  x98
085E:  CLRF   x97
....................    vpcb[4].di=0x1402; 
0860:  CLRF   xA7
0862:  CLRF   xA6
0864:  MOVWF  xA5
0866:  MOVLW  02
0868:  MOVWF  xA4
....................    vpcb[4].da=0x1402; 
086A:  CLRF   xAF
086C:  CLRF   xAE
086E:  MOVLW  14
0870:  MOVWF  xAD
0872:  MOVLW  02
0874:  MOVWF  xAC
....................    vpcb[4].df=0x1500; 
0876:  CLRF   xAB
0878:  CLRF   xAA
087A:  MOVLW  15
087C:  MOVWF  xA9
087E:  CLRF   xA8
....................    vpcb[0].estado=0; 
0880:  CLRF   x6C
....................    vpcb[1].estado=0; 
0882:  CLRF   x7D
....................    vpcb[2].estado=0; 
0884:  CLRF   x8E
....................    vpcb[3].estado=0; 
0886:  CLRF   x9F
....................    vpcb[4].estado=0; 
0888:  CLRF   xB0
088A:  GOTO   08BA (RETURN)
....................     
.................... } 
....................  
.................... void MCU_Init() 
.................... { 
....................    printf("Conectado.............*"); 
*
08A0:  MOVLW  42
08A2:  MOVWF  FF6
08A4:  MOVLW  03
08A6:  MOVWF  FF7
08A8:  CLRF   16
08AA:  BTFSC  FF2.7
08AC:  BSF    16.7
08AE:  BCF    FF2.7
08B0:  RCALL  028E
08B2:  BTFSC  16.7
08B4:  BSF    FF2.7
....................    Port_Init(); 
08B6:  BRA    07D2
....................    Procesos_Init(); 
08B8:  BRA    07E4
....................    inte_Init(); 
08BA:  BRA    088E
....................    Config_TMR0(); 
08BC:  BRA    0898
....................    setup_spi(FALSE); 
08BE:  CLRF   FC6
....................    setup_psp(PSP_DISABLED); 
08C0:  BCF    F96.4
....................    setup_comparator(NC_NC_NC_NC); 
08C2:  MOVLW  07
08C4:  MOVWF  FB4
08C6:  MOVF   F92,W
08C8:  MOVWF  F92
08CA:  MOVLW  07
08CC:  MOVWF  00
08CE:  DECFSZ 00,F
08D0:  BRA    08CE
08D2:  BRA    08D4
08D4:  NOP   
08D6:  MOVF   FB4,W
08D8:  BCF    FA1.6
....................    setup_vref(FALSE); 
08DA:  CLRF   FB5
....................    port_b_pullups(FALSE); 
08DC:  BSF    FF1.7
08DE:  GOTO   093A (RETURN)
.................... } 
....................  
.................... #ORG 0x4000, 0x4FFE 
.................... void Inicio_SO() 
.................... { 
....................    while (TRUE) 
....................    {        
....................       if(flagcmd){ 
*
4000:  BTFSS  5F.0
4002:  BRA    4008
....................          procesa_cmd(); 
4004:  GOTO   03D0
....................       } 
....................       switch(comando) 
4008:  MOVF   5E,W
400A:  XORLW  43
400C:  BZ    4014
400E:  XORLW  07
4010:  BZ    4030
4012:  BRA    404A
....................       { 
....................          case 'C':{if (valor2<10) cargar_proceso(valor2);break;} 
4014:  MOVF   3B,F
4016:  BNZ   402E
4018:  MOVF   3A,F
401A:  BNZ   402E
401C:  MOVF   39,F
401E:  BNZ   402E
4020:  MOVF   38,W
4022:  SUBLW  09
4024:  BNC   402E
4026:  MOVFF  38,C3
402A:  GOTO   0682
402E:  BRA    404A
....................          case 'D':{if (valor2<10) descargar_proceso(valor2);break;} 
4030:  MOVF   3B,F
4032:  BNZ   404A
4034:  MOVF   3A,F
4036:  BNZ   404A
4038:  MOVF   39,F
403A:  BNZ   404A
403C:  MOVF   38,W
403E:  SUBLW  09
4040:  BNC   404A
4042:  MOVFF  38,C3
4046:  GOTO   06EE
....................       } 
....................       comando='-'; 
404A:  MOVLW  2D
404C:  MOVWF  5E
....................       valor2=100; 
404E:  CLRF   3B
4050:  CLRF   3A
4052:  CLRF   39
4054:  MOVLW  64
4056:  MOVWF  38
....................       valor=0; 
4058:  CLRF   37
405A:  CLRF   36
405C:  CLRF   35
405E:  CLRF   34
....................        if(np>0) 
4060:  MOVF   17,F
4062:  BZ    414C
....................        { 
....................          if(vpcb[colap[0]].estado==1) 
4064:  MOVF   18,W
4066:  MULLW  11
4068:  MOVF   FF3,W
406A:  CLRF   xC4
406C:  MOVWF  xC3
406E:  MOVLW  0C
4070:  ADDWF  xC3,W
4072:  MOVWF  01
4074:  MOVLW  00
4076:  ADDWFC xC4,W
4078:  MOVWF  03
407A:  MOVF   01,W
407C:  ADDLW  60
407E:  MOVWF  FE9
4080:  MOVLW  00
4082:  ADDWFC 03,W
4084:  MOVWF  FEA
4086:  DECFSZ FEF,W
4088:  BRA    40E6
....................             {activar_timer(); 
408A:  CALL   07B0
....................              vpcb[colap[0]].estado=2; 
408E:  MOVF   18,W
4090:  MULLW  11
4092:  MOVF   FF3,W
4094:  CLRF   xC4
4096:  MOVWF  xC3
4098:  MOVLW  0C
409A:  ADDWF  xC3,W
409C:  MOVWF  01
409E:  MOVLW  00
40A0:  ADDWFC xC4,W
40A2:  MOVWF  03
40A4:  MOVF   01,W
40A6:  ADDLW  60
40A8:  MOVWF  FE9
40AA:  MOVLW  00
40AC:  ADDWFC 03,W
40AE:  MOVWF  FEA
40B0:  MOVLW  02
40B2:  MOVWF  FEF
....................              goto_address(vpcb[colap[0]].di); 
40B4:  MOVF   18,W
40B6:  MULLW  11
40B8:  MOVF   FF3,W
40BA:  CLRF   xC4
40BC:  MOVWF  xC3
40BE:  MOVLW  60
40C0:  ADDWF  xC3,W
40C2:  MOVWF  FE9
40C4:  MOVLW  00
40C6:  ADDWFC xC4,W
40C8:  MOVWF  FEA
40CA:  MOVFF  FEF,C5
40CE:  MOVFF  FEC,C6
40D2:  MOVFF  FEC,C7
40D6:  MOVFF  FEC,C8
40DA:  MOVFF  C6,FFA
40DE:  MOVFF  C5,FE8
40E2:  MOVWF  FF9
....................             } 
40E4:  BRA    414C
....................          else 
....................             {wreg=vpcb[colap[0]].wreg; 
40E6:  MOVF   18,W
40E8:  MULLW  11
40EA:  MOVF   FF3,W
40EC:  CLRF   xC4
40EE:  MOVWF  xC3
40F0:  MOVLW  0D
40F2:  ADDWF  xC3,W
40F4:  MOVWF  01
40F6:  MOVLW  00
40F8:  ADDWFC xC4,W
40FA:  MOVWF  03
40FC:  MOVF   01,W
40FE:  ADDLW  60
4100:  MOVWF  FE9
4102:  MOVLW  00
4104:  ADDWFC 03,W
4106:  MOVWF  FEA
4108:  MOVFF  FEF,FE8
....................              activar_timer(); 
410C:  CALL   07B0
....................              goto_address(vpcb[colap[0]].da); 
4110:  MOVF   18,W
4112:  MULLW  11
4114:  MOVF   FF3,W
4116:  CLRF   xC4
4118:  MOVWF  xC3
411A:  MOVLW  08
411C:  ADDWF  xC3,W
411E:  MOVWF  01
4120:  MOVLW  00
4122:  ADDWFC xC4,W
4124:  MOVWF  03
4126:  MOVF   01,W
4128:  ADDLW  60
412A:  MOVWF  FE9
412C:  MOVLW  00
412E:  ADDWFC 03,W
4130:  MOVWF  FEA
4132:  MOVFF  FEF,C3
4136:  MOVFF  FEC,C4
413A:  MOVFF  FEC,C5
413E:  MOVFF  FEC,C6
4142:  MOVFF  C4,FFA
4146:  MOVFF  C3,FE8
414A:  MOVWF  FF9
....................             } 
....................        } 
414C:  BRA    4000
....................    } 
414E:  RETURN 0
.................... } 
....................  
.................... void main(void) 
*
08E2:  CLRF   FF8
08E4:  BCF    FD0.7
08E6:  BSF    07.7
08E8:  BCF    FB8.3
08EA:  MOVLW  40
08EC:  MOVWF  FAF
08EE:  MOVLW  A6
08F0:  MOVWF  FAC
08F2:  MOVLW  90
08F4:  MOVWF  FAB
08F6:  CLRF   17
08F8:  CLRF   37
08FA:  CLRF   36
08FC:  CLRF   35
08FE:  CLRF   34
0900:  CLRF   3B
0902:  CLRF   3A
0904:  CLRF   39
0906:  CLRF   38
0908:  MOVLW  FE
090A:  MOVWF  51
090C:  MOVLW  18
090E:  MOVWF  50
0910:  CLRF   52
0912:  CLRF   5D
0914:  BCF    5F.0
0916:  MOVF   FC1,W
0918:  ANDLW  C0
091A:  IORLW  0F
091C:  MOVWF  FC1
091E:  MOVLW  07
0920:  MOVWF  FB4
.................... { 
....................    printf("Esperando conexión..*"); 
0922:  MOVLW  BC
0924:  MOVWF  FF6
0926:  MOVLW  07
0928:  MOVWF  FF7
092A:  CLRF   16
092C:  BTFSC  FF2.7
092E:  BSF    16.7
0930:  BCF    FF2.7
0932:  RCALL  028E
0934:  BTFSC  16.7
0936:  BSF    FF2.7
....................     
....................    MCU_Init(); 
0938:  BRA    08A0
....................    #asm 
....................    call 0x4000 
093A:  CALL   4000,1
....................    #endasm 
.................... } 
....................  
093E:  SLEEP 

Configuration Fuses:
   Word  1: CC27   PLL12 CPUDIV1 USBDIV HS FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
