CCS PCH C Compiler, Version 5.008, 5967               21-oct-14 16:12

               Filename:   D:\IGNACIO\ProgramacionGitHub\MT325-TiempoReal\Sistema\Programa PIC\SistemaPIC18f4550\ComunicacionSerial\ComSerial.lst

               ROM used:   3104 bytes (9%)
                           Largest free fragment is 12288
               RAM used:   215 (10%) at main() level
                           255 (12%) worst case
               Stack used: 6 locations (2 in main + 4 for interrupts)
               Stack size: 31

*
0000:  GOTO   092A
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   00A8
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   02E8
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVF   04,W
0098:  MOVFF  06,FE0
009C:  MOVFF  05,FD8
00A0:  RETFIE 0
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
*
028E:  TBLRD*+
0290:  MOVF   FF5,F
0292:  BZ    02AE
0294:  MOVFF  FF6,D9
0298:  MOVFF  FF7,DA
029C:  MOVF   FF5,W
029E:  BTFSS  F9E.4
02A0:  BRA    029E
02A2:  MOVWF  FAD
02A4:  MOVFF  D9,FF6
02A8:  MOVFF  DA,FF7
02AC:  BRA    028E
02AE:  RETURN 0
*
0308:  DATA 52,65
030A:  DATA 63,69
030C:  DATA 62,69
030E:  DATA 64,6F
0310:  DATA 00,00
0312:  DATA 50,72
0314:  DATA 6F,63
0316:  DATA 65,73
0318:  DATA 6F,20
031A:  DATA 25,69
031C:  DATA 20,63
031E:  DATA 61,72
0320:  DATA 67,61
0322:  DATA 64,6F
0324:  DATA 2E,20
0326:  DATA 2A,00
0328:  DATA 50,72
032A:  DATA 6F,63
032C:  DATA 65,73
032E:  DATA 6F,20
0330:  DATA 25,69
0332:  DATA 20,64
0334:  DATA 65,73
0336:  DATA 63,61
0338:  DATA 72,67
033A:  DATA 61,64
033C:  DATA 6F,2E
033E:  DATA 20,2A
0340:  DATA 00,00
0342:  DATA 43,6F
0344:  DATA 6E,65
0346:  DATA 63,74
0348:  DATA 61,64
034A:  DATA 6F,2E
034C:  DATA 2E,2E
034E:  DATA 2E,2E
0350:  DATA 2E,2E
0352:  DATA 2E,2E
0354:  DATA 2E,2E
0356:  DATA 2E,2E
0358:  DATA 2A,00
035A:  CLRF   xF9
035C:  CLRF   xFA
035E:  MOVLW  01
0360:  MOVWF  xFB
0362:  CLRF   FDA
0364:  CLRF   FD9
0366:  CLRF   xFE
0368:  MOVLW  F1
036A:  MOVWF  xFD
036C:  CLRF   FEA
036E:  MOVLW  F5
0370:  MOVWF  FE9
0372:  MOVFF  FE,FE2
0376:  MOVFF  FD,FE1
037A:  MOVFF  FB,FC
037E:  BCF    FD8.0
0380:  MOVF   FE5,W
0382:  MULWF  FEE
0384:  MOVF   FF3,W
0386:  ADDWFC xF9,F
0388:  MOVF   FF4,W
038A:  ADDWFC xFA,F
038C:  DECFSZ xFC,F
038E:  BRA    037E
0390:  MOVFF  F9,FDE
0394:  MOVFF  FA,F9
0398:  CLRF   xFA
039A:  BTFSC  FD8.0
039C:  INCF   xFA,F
039E:  INCF   xFD,F
03A0:  BTFSC  FD8.2
03A2:  INCF   xFE,F
03A4:  INCF   xFB,F
03A6:  MOVF   xFB,W
03A8:  SUBLW  05
03AA:  BNZ   036C
03AC:  RETURN 0
*
0588:  TBLRD*+
058A:  MOVFF  FF6,EA
058E:  MOVFF  FF7,EB
0592:  MOVF   FF5,W
0594:  BTFSS  F9E.4
0596:  BRA    0594
0598:  MOVWF  FAD
059A:  MOVFF  EA,FF6
059E:  MOVFF  EB,FF7
05A2:  DECFSZ xE9,F
05A4:  BRA    0588
05A6:  RETURN 0
05A8:  MOVF   xF0,W
05AA:  CLRF   01
05AC:  SUBWF  xEF,W
05AE:  BC    05B6
05B0:  MOVFF  EF,00
05B4:  BRA    05CE
05B6:  CLRF   00
05B8:  MOVLW  08
05BA:  MOVWF  xF1
05BC:  RLCF   xEF,F
05BE:  RLCF   00,F
05C0:  MOVF   xF0,W
05C2:  SUBWF  00,W
05C4:  BTFSC  FD8.0
05C6:  MOVWF  00
05C8:  RLCF   01,F
05CA:  DECFSZ xF1,F
05CC:  BRA    05BC
05CE:  RETURN 0
05D0:  MOVLW  20
05D2:  BTFSS  xEA.4
05D4:  MOVLW  30
05D6:  MOVWF  xEB
05D8:  MOVFF  E9,00
05DC:  BTFSS  xE9.7
05DE:  BRA    05F0
05E0:  COMF   00,F
05E2:  INCF   00,F
05E4:  MOVFF  00,E9
05E8:  MOVLW  2D
05EA:  MOVWF  xEB
05EC:  BSF    xEA.7
05EE:  BSF    xEA.0
05F0:  MOVF   01,W
05F2:  MOVFF  E9,EF
05F6:  MOVLW  64
05F8:  MOVWF  xF0
05FA:  RCALL  05A8
05FC:  MOVFF  00,E9
0600:  MOVLW  30
0602:  ADDWF  01,W
0604:  MOVWF  xEC
0606:  MOVFF  E9,EF
060A:  MOVLW  0A
060C:  MOVWF  xF0
060E:  RCALL  05A8
0610:  MOVLW  30
0612:  ADDWF  00,W
0614:  MOVWF  xEE
0616:  MOVLW  30
0618:  ADDWF  01,W
061A:  MOVWF  xED
061C:  MOVFF  EB,00
0620:  MOVLW  30
0622:  SUBWF  xEC,W
0624:  BZ    062E
0626:  BSF    xEA.1
0628:  BTFSC  xEA.7
062A:  BSF    xEA.2
062C:  BRA    0652
062E:  MOVFF  EB,EC
0632:  MOVLW  20
0634:  MOVWF  xEB
0636:  MOVLW  30
0638:  SUBWF  xED,W
063A:  BZ    0644
063C:  BSF    xEA.0
063E:  BTFSC  xEA.7
0640:  BSF    xEA.1
0642:  BRA    0652
0644:  BTFSS  FD8.2
0646:  BSF    xEA.0
0648:  BNZ   0652
064A:  MOVFF  EC,ED
064E:  MOVLW  20
0650:  MOVWF  xEC
0652:  BTFSC  xEA.2
0654:  BRA    0660
0656:  BTFSC  xEA.1
0658:  BRA    0668
065A:  BTFSC  xEA.0
065C:  BRA    0670
065E:  BRA    0678
0660:  MOVF   xEB,W
0662:  BTFSS  F9E.4
0664:  BRA    0662
0666:  MOVWF  FAD
0668:  MOVF   xEC,W
066A:  BTFSS  F9E.4
066C:  BRA    066A
066E:  MOVWF  FAD
0670:  MOVF   xED,W
0672:  BTFSS  F9E.4
0674:  BRA    0672
0676:  MOVWF  FAD
0678:  MOVF   xEE,W
067A:  BTFSS  F9E.4
067C:  BRA    067A
067E:  MOVWF  FAD
0680:  RETURN 0
*
07BC:  DATA 45,73
07BE:  DATA 70,65
07C0:  DATA 72,61
07C2:  DATA 6E,64
07C4:  DATA 6F,20
07C6:  DATA 63,6F
07C8:  DATA 6E,65
07CA:  DATA 78,69
07CC:  DATA F3,6E
07CE:  DATA 2E,2E
07D0:  DATA 2A,00
....................  
.................... #list 
....................  
....................  
.................... #use delay(clock=10000000) 
.................... #use rs232(baud=9600, xmit=PIN_C6,rcv=PIN_C7,bits=8,parity=N) 
.................... #fuses HS,NOPROTECT,NOWDT,NOLVP,CPUDIV1,nomclr 
.................... #define Tiempo 200 
....................  
.................... #use FAST_IO(A)  
.................... #use FAST_IO(B) 
.................... #use FAST_IO(D) 
....................  
.................... #byte T0CON=0xFD5 
.................... #byte wreg=0xFE8 
.................... #byte TOSU=0xFFF 
.................... #byte TOSH=0xFFE 
.................... #byte TOSL=0xFFD 
....................  
.................... int np=0; 
.................... int colap[6]; 
.................... int m; 
.................... int8 i,j,j1,j2,j3,j4; 
....................  
.................... int c1,c2; 
.................... int k1,k2,k3,k4,k5,k6; 
.................... int l1,l2,l3,l4,l5,l6; 
....................  
.................... char proceso; 
....................  
.................... int const lenbuff=10; 
.................... int32 valor=0; 
.................... int32 valor2=0; 
.................... int32 val1,val2,val3,val4,val5; 
.................... int16 quantum=65048; 
....................  
....................  
.................... int   xbuff=0x00; 
.................... char  cbuff[lenbuff]; 
.................... char  rcvchar=0x00; 
.................... char  comando; 
.................... int1  flagcmd=0; 
....................  
....................  
.................... struct pcb{ 
.................... int32 di; 
.................... int32 df;  
.................... int32 da; 
.................... int estado;  
.................... int wreg;  
.................... int status; 
.................... int bsr; 
.................... int id; 
.................... } vpcb[7]; 
....................  
.................... void activar_timer() 
.................... { 
....................    set_timer0(quantum); 
*
07B0:  MOVFF  51,FD7
07B4:  MOVFF  50,FD6
....................    enable_interrupts(INT_TIMER0); 
07B8:  BSF    FF2.5
07BA:  RETURN 0
.................... } 
....................  
.................... void desactivar_timer() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
00A2:  BCF    FF2.5
00A4:  GOTO   00AC (RETURN)
.................... } 
....................  
.................... void addcbuff(char c); 
.................... void mostrar_procesos(); 
.................... void descargar_proceso(int idp); 
.................... void Config_TMR0(); 
....................  
....................  
.................... #INT_TIMER0 
.................... void inter_quantum() 
00A8:  CLRF   xD9
.................... {  int i=0; 
....................    desactivar_timer(); 
00AA:  BRA    00A2
....................    vpcb[colap[0]].wreg=wreg; 
00AC:  MOVF   18,W
00AE:  MULLW  11
00B0:  MOVF   FF3,W
00B2:  CLRF   xDB
00B4:  MOVWF  xDA
00B6:  MOVLW  0D
00B8:  ADDWF  xDA,W
00BA:  MOVWF  01
00BC:  MOVLW  00
00BE:  ADDWFC xDB,W
00C0:  MOVWF  03
00C2:  MOVF   01,W
00C4:  ADDLW  60
00C6:  MOVWF  FE9
00C8:  MOVLW  00
00CA:  ADDWFC 03,W
00CC:  MOVWF  FEA
00CE:  MOVFF  FE8,FEF
....................    vpcb[colap[0]].da=(int32)TOSL; 
00D2:  MOVF   18,W
00D4:  MULLW  11
00D6:  MOVF   FF3,W
00D8:  CLRF   xDB
00DA:  MOVWF  xDA
00DC:  MOVLW  08
00DE:  ADDWF  xDA,W
00E0:  MOVWF  01
00E2:  MOVLW  00
00E4:  ADDWFC xDB,W
00E6:  MOVWF  03
00E8:  MOVF   01,W
00EA:  ADDLW  60
00EC:  MOVWF  FE9
00EE:  MOVLW  00
00F0:  ADDWFC 03,W
00F2:  MOVWF  FEA
00F4:  CLRF   01
00F6:  CLRF   02
00F8:  CLRF   03
00FA:  MOVFF  FFD,FEF
00FE:  MOVFF  01,FEC
0102:  MOVFF  02,FEC
0106:  MOVFF  03,FEC
....................    vpcb[colap[0]].da=vpcb[colap[0]].da|((int32)TOSH<<8); 
010A:  MOVF   18,W
010C:  MULLW  11
010E:  MOVF   FF3,W
0110:  CLRF   xDB
0112:  MOVWF  xDA
0114:  MOVLW  08
0116:  ADDWF  xDA,W
0118:  MOVWF  01
011A:  MOVLW  00
011C:  ADDWFC xDB,W
011E:  MOVWF  03
0120:  MOVF   01,W
0122:  ADDLW  60
0124:  MOVWF  01
0126:  MOVLW  00
0128:  ADDWFC 03,F
012A:  MOVFF  01,DA
012E:  MOVFF  03,DB
0132:  MOVF   18,W
0134:  MULLW  11
0136:  MOVF   FF3,W
0138:  CLRF   xDD
013A:  MOVWF  xDC
013C:  MOVLW  08
013E:  ADDWF  xDC,W
0140:  MOVWF  01
0142:  MOVLW  00
0144:  ADDWFC xDD,W
0146:  MOVWF  03
0148:  MOVF   01,W
014A:  ADDLW  60
014C:  MOVWF  FE9
014E:  MOVLW  00
0150:  ADDWFC 03,W
0152:  MOVWF  FEA
0154:  MOVFF  FEF,DC
0158:  MOVFF  FEC,DD
015C:  MOVFF  FEC,DE
0160:  MOVFF  FEC,DF
0164:  CLRF   xE2
0166:  CLRF   xE1
0168:  CLRF   00
016A:  MOVF   00,W
016C:  IORWF  xDC,W
016E:  MOVWF  00
0170:  MOVF   FFE,W
0172:  IORWF  xDD,W
0174:  MOVWF  01
0176:  MOVF   xE1,W
0178:  IORWF  xDE,W
017A:  MOVWF  02
017C:  MOVF   xE2,W
017E:  IORWF  xDF,W
0180:  MOVFF  DB,FEA
0184:  MOVFF  DA,FE9
0188:  MOVFF  00,FEF
018C:  MOVFF  01,FEC
0190:  MOVFF  02,FEC
0194:  MOVWF  FEC
....................    vpcb[colap[0]].da=vpcb[colap[0]].da|((int32)TOSU<<16); 
0196:  MOVF   18,W
0198:  MULLW  11
019A:  MOVF   FF3,W
019C:  CLRF   xDB
019E:  MOVWF  xDA
01A0:  MOVLW  08
01A2:  ADDWF  xDA,W
01A4:  MOVWF  01
01A6:  MOVLW  00
01A8:  ADDWFC xDB,W
01AA:  MOVWF  03
01AC:  MOVF   01,W
01AE:  ADDLW  60
01B0:  MOVWF  01
01B2:  MOVLW  00
01B4:  ADDWFC 03,F
01B6:  MOVFF  01,DA
01BA:  MOVFF  03,DB
01BE:  MOVF   18,W
01C0:  MULLW  11
01C2:  MOVF   FF3,W
01C4:  CLRF   xDD
01C6:  MOVWF  xDC
01C8:  MOVLW  08
01CA:  ADDWF  xDC,W
01CC:  MOVWF  01
01CE:  MOVLW  00
01D0:  ADDWFC xDD,W
01D2:  MOVWF  03
01D4:  MOVF   01,W
01D6:  ADDLW  60
01D8:  MOVWF  FE9
01DA:  MOVLW  00
01DC:  ADDWFC 03,W
01DE:  MOVWF  FEA
01E0:  MOVFF  FEF,DC
01E4:  MOVFF  FEC,DD
01E8:  MOVFF  FEC,DE
01EC:  MOVFF  FEC,DF
01F0:  CLRF   xE1
01F2:  CLRF   00
01F4:  CLRF   01
01F6:  MOVF   00,W
01F8:  IORWF  xDC,W
01FA:  MOVWF  00
01FC:  MOVF   01,W
01FE:  IORWF  xDD,W
0200:  MOVWF  01
0202:  MOVF   FFF,W
0204:  IORWF  xDE,W
0206:  MOVWF  02
0208:  MOVF   xE1,W
020A:  IORWF  xDF,W
020C:  MOVFF  DB,FEA
0210:  MOVFF  DA,FE9
0214:  MOVFF  00,FEF
0218:  MOVFF  01,FEC
021C:  MOVFF  02,FEC
0220:  MOVWF  FEC
....................    output_toggle(PIN_D6); 
0222:  BTG    F8C.6
....................    if(np>1) 
0224:  MOVF   17,W
0226:  SUBLW  01
0228:  BC    0280
....................    {  m=colap[0]; 
022A:  MOVFF  18,1E
....................       for(i=0;i<np-1;i++) 
022E:  CLRF   xD9
0230:  MOVLW  01
0232:  SUBWF  17,W
0234:  SUBWF  xD9,W
0236:  BC    026C
....................       {colap[i]=colap[i+1]; 
0238:  CLRF   03
023A:  MOVF   xD9,W
023C:  ADDLW  18
023E:  MOVWF  01
0240:  MOVLW  00
0242:  ADDWFC 03,F
0244:  MOVFF  03,DB
0248:  MOVLW  01
024A:  ADDWF  xD9,W
024C:  CLRF   03
024E:  ADDLW  18
0250:  MOVWF  FE9
0252:  MOVLW  00
0254:  ADDWFC 03,W
0256:  MOVWF  FEA
0258:  MOVFF  FEF,DC
025C:  MOVFF  DB,FEA
0260:  MOVFF  01,FE9
0264:  MOVFF  DC,FEF
0268:  INCF   xD9,F
026A:  BRA    0230
....................       } 
....................       colap[np-1]=m; 
026C:  MOVLW  01
026E:  SUBWF  17,W
0270:  CLRF   03
0272:  ADDLW  18
0274:  MOVWF  FE9
0276:  MOVLW  00
0278:  ADDWFC 03,W
027A:  MOVWF  FEA
027C:  MOVFF  1E,FEF
....................    } 
....................     
....................    TOSL=00; 
0280:  CLRF   FFD
....................    TOSH=40; 
0282:  MOVLW  28
0284:  MOVWF  FFE
....................    TOSU=00; 
0286:  CLRF   FFF
0288:  BCF    FF2.2
028A:  GOTO   0060
.................... }  
....................  
....................  
.................... void inte_Init()  // interrupcion de puerto serial 
.................... { 
....................    enable_interrupts(GLOBAL); 
*
08D6:  MOVLW  C0
08D8:  IORWF  FF2,F
....................    enable_interrupts(INT_RDA); 
08DA:  BSF    F9D.5
08DC:  GOTO   0904 (RETURN)
.................... } 
....................  
....................  
.................... #INT_RDA 
.................... void serial_isr() 
.................... { 
....................    printf("Recibido");     // se envia por Serial una palabra para verificar interrupcion 
*
02E8:  MOVLW  08
02EA:  MOVWF  FF6
02EC:  MOVLW  03
02EE:  MOVWF  FF7
02F0:  RCALL  028E
....................    rcvchar = 0x00; 
02F2:  CLRF   5D
....................    rcvchar = getc();    // se recibe el caracter enviado por la computadora 
02F4:  BTFSS  F9E.5
02F6:  BRA    02F4
02F8:  MOVFF  FAE,5D
....................    addcbuff(rcvchar);   // guarda el caracter en un buffer 
02FC:  MOVFF  5D,D9
0300:  BRA    02B0
0302:  BCF    F9E.5
0304:  GOTO   0060
.................... } 
....................  
.................... void addcbuff(char c)    
.................... { 
....................    switch(c) 
*
02B0:  MOVF   xD9,W
02B2:  XORLW  2A
02B4:  BZ    02B8
02B6:  BRA    02D0
....................    { 
....................       case '*':                  // en caso de recibir *, levanta el flag para saber que se termino de enviar un comando. 
....................          cbuff[xbuff++] = c; 
02B8:  MOVF   52,W
02BA:  INCF   52,F
02BC:  CLRF   03
02BE:  ADDLW  53
02C0:  MOVWF  FE9
02C2:  MOVLW  00
02C4:  ADDWFC 03,W
02C6:  MOVWF  FEA
02C8:  MOVFF  D9,FEF
....................          flagcmd = 1; 
02CC:  BSF    5F.0
....................       break; 
02CE:  BRA    02E4
....................       default: 
....................          cbuff[xbuff++] = c; 
02D0:  MOVF   52,W
02D2:  INCF   52,F
02D4:  CLRF   03
02D6:  ADDLW  53
02D8:  MOVWF  FE9
02DA:  MOVLW  00
02DC:  ADDWFC 03,W
02DE:  MOVWF  FEA
02E0:  MOVFF  D9,FEF
....................    } 
02E4:  GOTO   0302 (RETURN)
.................... } 
....................  
.................... void inicbuff(void)           // inicializa el buffer, limpiandolo 
.................... { 
....................    int i; 
....................    for (i=0; i<lenbuff;i++)       
*
03AE:  CLRF   xF1
03B0:  MOVF   xF1,W
03B2:  SUBLW  09
03B4:  BNC   03CA
....................    { 
....................       cbuff[i] = 0x00; 
03B6:  CLRF   03
03B8:  MOVF   xF1,W
03BA:  ADDLW  53
03BC:  MOVWF  FE9
03BE:  MOVLW  00
03C0:  ADDWFC 03,W
03C2:  MOVWF  FEA
03C4:  CLRF   FEF
03C6:  INCF   xF1,F
03C8:  BRA    03B0
....................    } 
....................    xbuff=0x00; 
03CA:  CLRF   52
03CC:  GOTO   0566 (RETURN)
.................... } 
....................  
.................... void procesa_cmd(void){             // procesa el ultimo comando guardado, un comando esta comprendido entre $ hasta *  
03D0:  CLRF   xE6
....................   
....................    int i, j=0;                       
....................    char salida[lenbuff];            // Argumento de comando (si lo tiene) 
....................    disable_interrupts(int_rda);      
03D2:  BCF    F9D.5
....................    flagcmd=0;                       // Desactivo flag de comando pendiente. 
03D4:  BCF    5F.0
....................    for (i=0;i<xbuff;i++) 
03D6:  CLRF   xE5
03D8:  MOVF   52,W
03DA:  SUBWF  xE5,W
03DC:  BTFSC  FD8.0
03DE:  BRA    0564
....................    { 
....................       if (cbuff[i] == '$'){         // verifica que tenga '$' 
03E0:  CLRF   03
03E2:  MOVF   xE5,W
03E4:  ADDLW  53
03E6:  MOVWF  FE9
03E8:  MOVLW  00
03EA:  ADDWFC 03,W
03EC:  MOVWF  FEA
03EE:  MOVF   FEF,W
03F0:  SUBLW  24
03F2:  BTFSS  FD8.2
03F4:  BRA    0560
....................          while((cbuff[i] != '*') & (i<xbuff))   // hasta que encuentre * 
03F6:  CLRF   03
03F8:  MOVF   xE5,W
03FA:  ADDLW  53
03FC:  MOVWF  FE9
03FE:  MOVLW  00
0400:  ADDWFC 03,W
0402:  MOVWF  FEA
0404:  MOVF   FEF,W
0406:  SUBLW  2A
0408:  BNZ   040E
040A:  MOVLW  00
040C:  BRA    0410
040E:  MOVLW  01
0410:  MOVWF  xF1
0412:  MOVF   52,W
0414:  SUBWF  xE5,W
0416:  BNC   041C
0418:  MOVLW  00
041A:  BRA    041E
041C:  MOVLW  01
041E:  ANDWF  xF1,W
0420:  BZ    045A
....................          { 
....................             salida[j++]=cbuff[i++]; 
0422:  MOVF   xE6,W
0424:  INCF   xE6,F
0426:  CLRF   03
0428:  ADDLW  E7
042A:  MOVWF  01
042C:  MOVLW  00
042E:  ADDWFC 03,F
0430:  MOVFF  01,F1
0434:  MOVFF  03,F2
0438:  MOVF   xE5,W
043A:  INCF   xE5,F
043C:  CLRF   03
043E:  ADDLW  53
0440:  MOVWF  FE9
0442:  MOVLW  00
0444:  ADDWFC 03,W
0446:  MOVWF  FEA
0448:  MOVFF  FEF,F3
044C:  MOVFF  F2,FEA
0450:  MOVFF  01,FE9
0454:  MOVFF  F3,FEF
0458:  BRA    03F6
....................          } 
....................          comando = salida[1]; 
045A:  MOVFF  E8,5E
....................          valor2 = salida[2] -'0' + 1; 
045E:  MOVLW  30
0460:  SUBWF  xE9,W
0462:  ADDLW  01
0464:  MOVWF  38
0466:  CLRF   39
0468:  CLRF   3A
046A:  CLRF   3B
....................          val1 = salida[2] - '0'; 
046C:  MOVLW  30
046E:  SUBWF  xE9,W
0470:  MOVWF  3C
0472:  CLRF   3D
0474:  CLRF   3E
0476:  CLRF   3F
....................          val1 = val1; 
....................          val2 = salida[3] - '0'; 
0478:  MOVLW  30
047A:  SUBWF  xEA,W
047C:  MOVWF  40
047E:  CLRF   41
0480:  CLRF   42
0482:  CLRF   43
....................          val2 = val1*10 + val2; 
0484:  MOVFF  3F,F4
0488:  MOVFF  3E,F3
048C:  MOVFF  3D,F2
0490:  MOVFF  3C,F1
0494:  CLRF   xF8
0496:  CLRF   xF7
0498:  CLRF   xF6
049A:  MOVLW  0A
049C:  MOVWF  xF5
049E:  RCALL  035A
04A0:  MOVF   00,W
04A2:  ADDWF  40,F
04A4:  MOVF   01,W
04A6:  ADDWFC 41,F
04A8:  MOVF   02,W
04AA:  ADDWFC 42,F
04AC:  MOVF   03,W
04AE:  ADDWFC 43,F
....................          val3 = salida[4] - '0'; 
04B0:  MOVLW  30
04B2:  SUBWF  xEB,W
04B4:  MOVWF  44
04B6:  CLRF   45
04B8:  CLRF   46
04BA:  CLRF   47
....................          val3 = val2*10 +val3; 
04BC:  MOVFF  43,F4
04C0:  MOVFF  42,F3
04C4:  MOVFF  41,F2
04C8:  MOVFF  40,F1
04CC:  CLRF   xF8
04CE:  CLRF   xF7
04D0:  CLRF   xF6
04D2:  MOVLW  0A
04D4:  MOVWF  xF5
04D6:  RCALL  035A
04D8:  MOVF   00,W
04DA:  ADDWF  44,F
04DC:  MOVF   01,W
04DE:  ADDWFC 45,F
04E0:  MOVF   02,W
04E2:  ADDWFC 46,F
04E4:  MOVF   03,W
04E6:  ADDWFC 47,F
....................          val4 = salida[5] - '0'; 
04E8:  MOVLW  30
04EA:  SUBWF  xEC,W
04EC:  MOVWF  48
04EE:  CLRF   49
04F0:  CLRF   4A
04F2:  CLRF   4B
....................          val4 = val3*10+val4; 
04F4:  MOVFF  47,F4
04F8:  MOVFF  46,F3
04FC:  MOVFF  45,F2
0500:  MOVFF  44,F1
0504:  CLRF   xF8
0506:  CLRF   xF7
0508:  CLRF   xF6
050A:  MOVLW  0A
050C:  MOVWF  xF5
050E:  RCALL  035A
0510:  MOVF   00,W
0512:  ADDWF  48,F
0514:  MOVF   01,W
0516:  ADDWFC 49,F
0518:  MOVF   02,W
051A:  ADDWFC 4A,F
051C:  MOVF   03,W
051E:  ADDWFC 4B,F
....................          val5 = salida[6]-'0'; 
0520:  MOVLW  30
0522:  SUBWF  xED,W
0524:  MOVWF  4C
0526:  CLRF   4D
0528:  CLRF   4E
052A:  CLRF   4F
....................          valor = val4*10 + val5; 
052C:  MOVFF  4B,F4
0530:  MOVFF  4A,F3
0534:  MOVFF  49,F2
0538:  MOVFF  48,F1
053C:  CLRF   xF8
053E:  CLRF   xF7
0540:  CLRF   xF6
0542:  MOVLW  0A
0544:  MOVWF  xF5
0546:  RCALL  035A
0548:  MOVF   4C,W
054A:  ADDWF  00,W
054C:  MOVWF  34
054E:  MOVF   4D,W
0550:  ADDWFC 01,W
0552:  MOVWF  35
0554:  MOVF   4E,W
0556:  ADDWFC 02,W
0558:  MOVWF  36
055A:  MOVF   4F,W
055C:  ADDWFC 03,W
055E:  MOVWF  37
....................       } 
0560:  INCF   xE5,F
0562:  BRA    03D8
....................    } 
....................    inicbuff();                            // Borro buffer. 
0564:  BRA    03AE
....................    for(i=0;i<lenbuff;i++)                 // Bucle que pone a 0 todos los 
0566:  CLRF   xE5
0568:  MOVF   xE5,W
056A:  SUBLW  09
056C:  BNC   0582
....................    { 
....................       salida[i]=0x00;                     // caracteres en el argumento 
056E:  CLRF   03
0570:  MOVF   xE5,W
0572:  ADDLW  E7
0574:  MOVWF  FE9
0576:  MOVLW  00
0578:  ADDWFC 03,W
057A:  MOVWF  FEA
057C:  CLRF   FEF
057E:  INCF   xE5,F
0580:  BRA    0568
....................    } 
....................    enable_interrupts(int_rda);             
0582:  BSF    F9D.5
0584:  GOTO   4006 (RETURN)
.................... } 
....................  
.................... //PROGRAMA 1: Luces Secuenciales - Bucle Infinito 
....................  
.................... #ORG 0x1000, 0x1100 
.................... void ROML_LedA1() 
.................... { 
....................    set_tris_a(0x00); 
*
1000:  MOVLW  00
1002:  MOVWF  F92
....................    while(TRUE) 
....................    { 
....................       for (j1=0;j1<3;++j1) 
1004:  CLRF   21
1006:  MOVF   21,W
1008:  SUBLW  02
100A:  BNC   1042
....................       { 
....................          IF(j1==0) 
100C:  MOVF   21,F
100E:  BNZ   1014
....................          { 
....................             OUTPUT_BIT(PIN_A0,0); 
1010:  BCF    F89.0
....................             OUTPUT_BIT(PIN_A1,0); 
1012:  BCF    F89.1
....................          } 
....................          IF(j1==1){OUTPUT_BIT(PIN_A0,1);} 
1014:  DECFSZ 21,W
1016:  BRA    101A
1018:  BSF    F89.0
....................          IF(j1==2){OUTPUT_BIT(PIN_A1,1);} 
101A:  MOVF   21,W
101C:  SUBLW  02
101E:  BNZ   1022
1020:  BSF    F89.1
....................          for (k1=1;k1<200;++k1){for (l1=1;l1<200;++l1){}} 
1022:  MOVLW  01
1024:  MOVWF  27
1026:  MOVF   27,W
1028:  SUBLW  C7
102A:  BNC   103E
102C:  MOVLW  01
102E:  MOVWF  2D
1030:  MOVF   2D,W
1032:  SUBLW  C7
1034:  BNC   103A
1036:  INCF   2D,F
1038:  BRA    1030
103A:  INCF   27,F
103C:  BRA    1026
103E:  INCF   21,F
1040:  BRA    1006
....................       } 
1042:  BRA    1004
....................    } 
1044:  RETURN 0
.................... } 
....................  
.................... //PROGRAMA 2: Luces Secuenciales 2 - Bucle Infinito 
....................  
.................... #ORG 0x1102, 0x1200 
.................... void ROML_LedA2() 
.................... { 
....................    set_tris_d(0x00); 
*
1102:  MOVLW  00
1104:  MOVWF  F95
....................    while(TRUE) 
....................    { 
....................       for (j2=0;j2<3;++j2) 
1106:  CLRF   22
1108:  MOVF   22,W
110A:  SUBLW  02
110C:  BNC   1146
....................       { 
....................          IF(j2==0) 
110E:  MOVF   22,F
1110:  BNZ   1116
....................          { 
....................             OUTPUT_BIT(PIN_D2,0); 
1112:  BCF    F8C.2
....................             OUTPUT_BIT(PIN_D3,0); 
1114:  BCF    F8C.3
....................          } 
....................          IF(j2==1) 
1116:  DECFSZ 22,W
1118:  BRA    111C
....................          { 
....................             OUTPUT_BIT(PIN_D2,1); 
111A:  BSF    F8C.2
....................          } 
....................          IF(j2==2) 
111C:  MOVF   22,W
111E:  SUBLW  02
1120:  BNZ   1126
....................          { 
....................             OUTPUT_BIT(PIN_D2,0); 
1122:  BCF    F8C.2
....................             OUTPUT_BIT(PIN_D3,1); 
1124:  BSF    F8C.3
....................          }          
....................          for (k2=1;k2<100;++k2){for (l2=1;l2<200;++l2){}} 
1126:  MOVLW  01
1128:  MOVWF  28
112A:  MOVF   28,W
112C:  SUBLW  63
112E:  BNC   1142
1130:  MOVLW  01
1132:  MOVWF  2E
1134:  MOVF   2E,W
1136:  SUBLW  C7
1138:  BNC   113E
113A:  INCF   2E,F
113C:  BRA    1134
113E:  INCF   28,F
1140:  BRA    112A
1142:  INCF   22,F
1144:  BRA    1108
....................       } 
1146:  BRA    1106
....................    } 
1148:  RETURN 0
.................... } 
....................  
.................... //PROGRAMA 5: Luces Secuenciales C - Finito 
....................  
.................... #ORG 0x1402, 0x1500 
.................... void voidTask_LedC1(){ 
.................... while(TRUE){ 
....................    while(TRUE) 
....................    { 
....................       for (c1=0;c1<5;c1++) 
*
1402:  CLRF   25
1404:  MOVF   25,W
1406:  SUBLW  04
1408:  BNC   144E
....................       { 
....................          for (j3=0;j3<3;++j3) 
140A:  CLRF   23
140C:  MOVF   23,W
140E:  SUBLW  02
1410:  BNC   144A
....................          { 
....................             IF(j3==0) 
1412:  MOVF   23,F
1414:  BNZ   141A
....................             { 
....................                OUTPUT_BIT(PIN_D0,0); 
1416:  BCF    F8C.0
....................                OUTPUT_BIT(PIN_D1,0); 
1418:  BCF    F8C.1
....................             } 
....................             IF(j3==1) 
141A:  DECFSZ 23,W
141C:  BRA    1420
....................             { 
....................                OUTPUT_BIT(PIN_D0,1); 
141E:  BSF    F8C.0
....................             } 
....................             IF(j3==2) 
1420:  MOVF   23,W
1422:  SUBLW  02
1424:  BNZ   142A
....................             { 
....................                OUTPUT_BIT(PIN_D0,0); 
1426:  BCF    F8C.0
....................                OUTPUT_BIT(PIN_D1,1); 
1428:  BSF    F8C.1
....................             }          
....................             for (k5=1;k5<200;++k5){for (l5=1;l5<200;++l5){}} 
142A:  MOVLW  01
142C:  MOVWF  2B
142E:  MOVF   2B,W
1430:  SUBLW  C7
1432:  BNC   1446
1434:  MOVLW  01
1436:  MOVWF  31
1438:  MOVF   31,W
143A:  SUBLW  C7
143C:  BNC   1442
143E:  INCF   31,F
1440:  BRA    1438
1442:  INCF   2B,F
1444:  BRA    142E
1446:  INCF   23,F
1448:  BRA    140C
....................          } 
144A:  INCF   25,F
144C:  BRA    1404
....................       } 
....................       comando='D'; 
144E:  MOVLW  44
1450:  MOVWF  5E
....................       valor2=5; 
1452:  CLRF   3B
1454:  CLRF   3A
1456:  CLRF   39
1458:  MOVLW  05
145A:  MOVWF  38
145C:  BRA    1402
....................    } 
145E:  BRA    1402
.................... } 
1460:  RETURN 0
.................... } 
....................  
.................... //PROGRAMA 6: Luces Secuenciales C2 - Finito 
....................  
.................... #ORG 0x1502, 0x1600 
.................... void voidTask_LedC2(){ 
....................    while(TRUE){ 
....................       while(TRUE) 
....................       { 
....................          for (c2=0;c2<5;c2++) 
*
1502:  CLRF   26
1504:  MOVF   26,W
1506:  SUBLW  04
1508:  BNC   154E
....................          { 
....................             for (j4=0;j4<3;++j4) 
150A:  CLRF   24
150C:  MOVF   24,W
150E:  SUBLW  02
1510:  BNC   154A
....................             { 
....................                IF(j4==0) 
1512:  MOVF   24,F
1514:  BNZ   151A
....................                { 
....................                   OUTPUT_BIT(PIN_D2,0); 
1516:  BCF    F8C.2
....................                   OUTPUT_BIT(PIN_D3,0); 
1518:  BCF    F8C.3
....................                } 
....................                IF(j4==1) 
151A:  DECFSZ 24,W
151C:  BRA    1520
....................                { 
....................                   OUTPUT_BIT(PIN_D2,1); 
151E:  BSF    F8C.2
....................                } 
....................                IF(j4==2) 
1520:  MOVF   24,W
1522:  SUBLW  02
1524:  BNZ   152A
....................                { 
....................                   OUTPUT_BIT(PIN_D2,0); 
1526:  BCF    F8C.2
....................                   OUTPUT_BIT(PIN_D3,1); 
1528:  BSF    F8C.3
....................                }          
....................                for (k6=1;k6<200;++k6){for (l6=1;l6<200;++l6){}} 
152A:  MOVLW  01
152C:  MOVWF  2C
152E:  MOVF   2C,W
1530:  SUBLW  C7
1532:  BNC   1546
1534:  MOVLW  01
1536:  MOVWF  32
1538:  MOVF   32,W
153A:  SUBLW  C7
153C:  BNC   1542
153E:  INCF   32,F
1540:  BRA    1538
1542:  INCF   2C,F
1544:  BRA    152E
1546:  INCF   24,F
1548:  BRA    150C
....................             } 
154A:  INCF   26,F
154C:  BRA    1504
....................          } 
....................          comando='D'; 
154E:  MOVLW  44
1550:  MOVWF  5E
....................          valor2=6; 
1552:  CLRF   3B
1554:  CLRF   3A
1556:  CLRF   39
1558:  MOVLW  06
155A:  MOVWF  38
155C:  BRA    1502
....................       } 
155E:  BRA    1502
....................    } 
1560:  RETURN 0
.................... } 
....................  
.................... void cargar_proceso(int idp) 
.................... { 
....................     colap[np]=idp-1; 
*
0682:  CLRF   03
0684:  MOVF   17,W
0686:  ADDLW  18
0688:  MOVWF  FE9
068A:  MOVLW  00
068C:  ADDWFC 03,W
068E:  MOVWF  FEA
0690:  MOVLW  01
0692:  SUBWF  xE5,W
0694:  MOVWF  FEF
....................     vpcb[idp-1].estado=1; 
0696:  MOVLW  01
0698:  SUBWF  xE5,W
069A:  MULLW  11
069C:  MOVF   FF3,W
069E:  CLRF   xE7
06A0:  MOVWF  xE6
06A2:  MOVLW  0C
06A4:  ADDWF  xE6,W
06A6:  MOVWF  01
06A8:  MOVLW  00
06AA:  ADDWFC xE7,W
06AC:  MOVWF  03
06AE:  MOVF   01,W
06B0:  ADDLW  60
06B2:  MOVWF  FE9
06B4:  MOVLW  00
06B6:  ADDWFC 03,W
06B8:  MOVWF  FEA
06BA:  MOVLW  01
06BC:  MOVWF  FEF
....................     printf("Proceso %i cargado. *",idp); 
06BE:  MOVLW  12
06C0:  MOVWF  FF6
06C2:  MOVLW  03
06C4:  MOVWF  FF7
06C6:  MOVLW  08
06C8:  MOVWF  xE9
06CA:  RCALL  0588
06CC:  MOVFF  E5,E9
06D0:  MOVLW  18
06D2:  MOVWF  xEA
06D4:  RCALL  05D0
06D6:  MOVLW  1C
06D8:  MOVWF  FF6
06DA:  MOVLW  03
06DC:  MOVWF  FF7
06DE:  MOVLW  0B
06E0:  MOVWF  xE9
06E2:  RCALL  0588
....................     proceso=10; 
06E4:  MOVLW  0A
06E6:  MOVWF  33
....................     np++; 
06E8:  INCF   17,F
06EA:  GOTO   402C (RETURN)
.................... } 
....................  
.................... void descargar_proceso(int idp) 
.................... { 
....................    int s,d,f; 
....................    for(s=0;s<np;s++) 
06EE:  CLRF   xE6
06F0:  MOVF   17,W
06F2:  SUBWF  xE6,W
06F4:  BC    0718
....................       {if(colap[s]==idp-1) 
06F6:  CLRF   03
06F8:  MOVF   xE6,W
06FA:  ADDLW  18
06FC:  MOVWF  FE9
06FE:  MOVLW  00
0700:  ADDWFC 03,W
0702:  MOVWF  FEA
0704:  MOVFF  FEF,E9
0708:  MOVLW  01
070A:  SUBWF  xE5,W
070C:  SUBWF  xE9,W
070E:  BNZ   0714
....................          {d=s;} 
0710:  MOVFF  E6,E7
0714:  INCF   xE6,F
0716:  BRA    06F0
....................       } 
....................    f=np-1; 
0718:  MOVLW  01
071A:  SUBWF  17,W
071C:  MOVWF  xE8
....................    for(s=d;s<f;s++) 
071E:  MOVFF  E7,E6
0722:  MOVF   xE8,W
0724:  SUBWF  xE6,W
0726:  BC    075C
....................       {colap[s]=colap[s+1]; 
0728:  CLRF   03
072A:  MOVF   xE6,W
072C:  ADDLW  18
072E:  MOVWF  01
0730:  MOVLW  00
0732:  ADDWFC 03,F
0734:  MOVFF  03,EA
0738:  MOVLW  01
073A:  ADDWF  xE6,W
073C:  CLRF   03
073E:  ADDLW  18
0740:  MOVWF  FE9
0742:  MOVLW  00
0744:  ADDWFC 03,W
0746:  MOVWF  FEA
0748:  MOVFF  FEF,EB
074C:  MOVFF  EA,FEA
0750:  MOVFF  01,FE9
0754:  MOVFF  EB,FEF
0758:  INCF   xE6,F
075A:  BRA    0722
....................       } 
....................    np--;    
075C:  DECF   17,F
....................    vpcb[idp-1].estado=0; 
075E:  MOVLW  01
0760:  SUBWF  xE5,W
0762:  MULLW  11
0764:  MOVF   FF3,W
0766:  CLRF   xEA
0768:  MOVWF  xE9
076A:  MOVLW  0C
076C:  ADDWF  xE9,W
076E:  MOVWF  01
0770:  MOVLW  00
0772:  ADDWFC xEA,W
0774:  MOVWF  03
0776:  MOVF   01,W
0778:  ADDLW  60
077A:  MOVWF  FE9
077C:  MOVLW  00
077E:  ADDWFC 03,W
0780:  MOVWF  FEA
0782:  CLRF   FEF
....................    proceso=0; 
0784:  CLRF   33
....................    printf("Proceso %i descargado. *",idp); 
0786:  MOVLW  28
0788:  MOVWF  FF6
078A:  MOVLW  03
078C:  MOVWF  FF7
078E:  MOVLW  08
0790:  MOVWF  xE9
0792:  RCALL  0588
0794:  MOVFF  E5,E9
0798:  MOVLW  18
079A:  MOVWF  xEA
079C:  RCALL  05D0
079E:  MOVLW  32
07A0:  MOVWF  FF6
07A2:  MOVLW  03
07A4:  MOVWF  FF7
07A6:  MOVLW  0E
07A8:  MOVWF  xE9
07AA:  RCALL  0588
07AC:  GOTO   4048 (RETURN)
.................... } 
....................  
.................... void Port_Init() 
.................... { 
....................    set_tris_b(0x00); 
*
07D2:  MOVLW  00
07D4:  MOVWF  F93
....................    set_tris_d(0x00); 
07D6:  MOVWF  F95
....................    set_tris_a(0x00); 
07D8:  MOVWF  F92
....................    output_b(0x00); 
07DA:  CLRF   F8A
....................    output_d(0x00); 
07DC:  CLRF   F8C
....................    output_a(0x00); 
07DE:  CLRF   F89
07E0:  GOTO   0900 (RETURN)
.................... } 
....................  
.................... void Config_TMR0() 
.................... { 
....................    T0CON=0b10000111; 
*
08E0:  MOVLW  87
08E2:  MOVWF  FD5
08E4:  GOTO   0906 (RETURN)
....................  
.................... } 
....................  
.................... void Procesos_Init() 
.................... { 
....................    vpcb[0].di=0x1000; 
*
07E4:  CLRF   x63
07E6:  CLRF   x62
07E8:  MOVLW  10
07EA:  MOVWF  x61
07EC:  CLRF   x60
....................    vpcb[0].da=0x1000;    
07EE:  CLRF   x6B
07F0:  CLRF   x6A
07F2:  MOVWF  x69
07F4:  CLRF   x68
....................    vpcb[0].df=0x1100; 
07F6:  CLRF   x67
07F8:  CLRF   x66
07FA:  MOVLW  11
07FC:  MOVWF  x65
07FE:  CLRF   x64
....................    vpcb[1].di=0x1102; 
0800:  CLRF   x74
0802:  CLRF   x73
0804:  MOVWF  x72
0806:  MOVLW  02
0808:  MOVWF  x71
....................    vpcb[1].da=0x1102; 
080A:  CLRF   x7C
080C:  CLRF   x7B
080E:  MOVLW  11
0810:  MOVWF  x7A
0812:  MOVLW  02
0814:  MOVWF  x79
....................    vpcb[1].df=0x1200; 
0816:  CLRF   x78
0818:  CLRF   x77
081A:  MOVLW  12
081C:  MOVWF  x76
081E:  CLRF   x75
....................    vpcb[2].di=0x1202; 
0820:  CLRF   x85
0822:  CLRF   x84
0824:  MOVWF  x83
0826:  MOVLW  02
0828:  MOVWF  x82
....................    vpcb[2].da=0x1202; 
082A:  CLRF   x8D
082C:  CLRF   x8C
082E:  MOVLW  12
0830:  MOVWF  x8B
0832:  MOVLW  02
0834:  MOVWF  x8A
....................    vpcb[2].df=0x1300; 
0836:  CLRF   x89
0838:  CLRF   x88
083A:  MOVLW  13
083C:  MOVWF  x87
083E:  CLRF   x86
....................    vpcb[3].di=0x1302; 
0840:  CLRF   x96
0842:  CLRF   x95
0844:  MOVWF  x94
0846:  MOVLW  02
0848:  MOVWF  x93
....................    vpcb[3].da=0x1302; 
084A:  CLRF   x9E
084C:  CLRF   x9D
084E:  MOVLW  13
0850:  MOVWF  x9C
0852:  MOVLW  02
0854:  MOVWF  x9B
....................    vpcb[3].df=0x1400; 
0856:  CLRF   x9A
0858:  CLRF   x99
085A:  MOVLW  14
085C:  MOVWF  x98
085E:  CLRF   x97
....................    vpcb[4].di=0x1402; 
0860:  CLRF   xA7
0862:  CLRF   xA6
0864:  MOVWF  xA5
0866:  MOVLW  02
0868:  MOVWF  xA4
....................    vpcb[4].da=0x1402; 
086A:  CLRF   xAF
086C:  CLRF   xAE
086E:  MOVLW  14
0870:  MOVWF  xAD
0872:  MOVLW  02
0874:  MOVWF  xAC
....................    vpcb[4].df=0x1500; 
0876:  CLRF   xAB
0878:  CLRF   xAA
087A:  MOVLW  15
087C:  MOVWF  xA9
087E:  CLRF   xA8
....................    vpcb[5].di=0x1502; 
0880:  CLRF   xB8
0882:  CLRF   xB7
0884:  MOVWF  xB6
0886:  MOVLW  02
0888:  MOVWF  xB5
....................    vpcb[5].da=0x1502; 
088A:  CLRF   xC0
088C:  CLRF   xBF
088E:  MOVLW  15
0890:  MOVWF  xBE
0892:  MOVLW  02
0894:  MOVWF  xBD
....................    vpcb[5].df=0x1600; 
0896:  CLRF   xBC
0898:  CLRF   xBB
089A:  MOVLW  16
089C:  MOVWF  xBA
089E:  CLRF   xB9
....................    vpcb[6].di=0x2502; 
08A0:  CLRF   xC9
08A2:  CLRF   xC8
08A4:  MOVLW  25
08A6:  MOVWF  xC7
08A8:  MOVLW  02
08AA:  MOVWF  xC6
....................    vpcb[6].da=0x2502; 
08AC:  CLRF   xD1
08AE:  CLRF   xD0
08B0:  MOVLW  25
08B2:  MOVWF  xCF
08B4:  MOVLW  02
08B6:  MOVWF  xCE
....................    vpcb[6].df=0x2850; 
08B8:  CLRF   xCD
08BA:  CLRF   xCC
08BC:  MOVLW  28
08BE:  MOVWF  xCB
08C0:  MOVLW  50
08C2:  MOVWF  xCA
....................    vpcb[0].estado=0; 
08C4:  CLRF   x6C
....................    vpcb[1].estado=0; 
08C6:  CLRF   x7D
....................    vpcb[2].estado=0; 
08C8:  CLRF   x8E
....................    vpcb[3].estado=0; 
08CA:  CLRF   x9F
....................    vpcb[4].estado=0; 
08CC:  CLRF   xB0
....................    vpcb[5].estado=0; 
08CE:  CLRF   xC1
....................    vpcb[6].estado=0; 
08D0:  CLRF   xD2
08D2:  GOTO   0902 (RETURN)
....................     
.................... } 
....................  
.................... void MCU_Init() 
.................... { 
....................    printf("Conectado.............*"); 
*
08E8:  MOVLW  42
08EA:  MOVWF  FF6
08EC:  MOVLW  03
08EE:  MOVWF  FF7
08F0:  CLRF   16
08F2:  BTFSC  FF2.7
08F4:  BSF    16.7
08F6:  BCF    FF2.7
08F8:  RCALL  028E
08FA:  BTFSC  16.7
08FC:  BSF    FF2.7
....................    Port_Init(); 
08FE:  BRA    07D2
....................    Procesos_Init(); 
0900:  BRA    07E4
....................    inte_Init(); 
0902:  BRA    08D6
....................    Config_TMR0(); 
0904:  BRA    08E0
....................    setup_spi(FALSE); 
0906:  CLRF   FC6
....................    setup_psp(PSP_DISABLED); 
0908:  BCF    F96.4
....................    setup_comparator(NC_NC_NC_NC); 
090A:  MOVLW  07
090C:  MOVWF  FB4
090E:  MOVF   F92,W
0910:  MOVWF  F92
0912:  MOVLW  07
0914:  MOVWF  00
0916:  DECFSZ 00,F
0918:  BRA    0916
091A:  BRA    091C
091C:  NOP   
091E:  MOVF   FB4,W
0920:  BCF    FA1.6
....................    setup_vref(FALSE); 
0922:  CLRF   FB5
....................    port_b_pullups(FALSE); 
0924:  BSF    FF1.7
0926:  GOTO   0982 (RETURN)
.................... } 
....................  
.................... #ORG 0x4000, 0x4FFE 
.................... void Inicio_SO() 
.................... { 
....................    while (TRUE) 
....................    {        
....................       if(flagcmd) procesa_cmd(); 
*
4000:  BTFSC  5F.0
4002:  GOTO   03D0
....................       switch(comando) 
4006:  MOVF   5E,W
4008:  XORLW  43
400A:  BZ    4012
400C:  XORLW  07
400E:  BZ    402E
4010:  BRA    4048
....................       { 
....................          case 'C':{if (valor2<10) cargar_proceso(valor2);break;} 
4012:  MOVF   3B,F
4014:  BNZ   402C
4016:  MOVF   3A,F
4018:  BNZ   402C
401A:  MOVF   39,F
401C:  BNZ   402C
401E:  MOVF   38,W
4020:  SUBLW  09
4022:  BNC   402C
4024:  MOVFF  38,E5
4028:  GOTO   0682
402C:  BRA    4048
....................          case 'D':{if (valor2<10) descargar_proceso(valor2);break;} 
402E:  MOVF   3B,F
4030:  BNZ   4048
4032:  MOVF   3A,F
4034:  BNZ   4048
4036:  MOVF   39,F
4038:  BNZ   4048
403A:  MOVF   38,W
403C:  SUBLW  09
403E:  BNC   4048
4040:  MOVFF  38,E5
4044:  GOTO   06EE
....................       } 
....................       comando='-'; 
4048:  MOVLW  2D
404A:  MOVWF  5E
....................       valor2=100; 
404C:  CLRF   3B
404E:  CLRF   3A
4050:  CLRF   39
4052:  MOVLW  64
4054:  MOVWF  38
....................       valor=0; 
4056:  CLRF   37
4058:  CLRF   36
405A:  CLRF   35
405C:  CLRF   34
....................        if(np>0) 
405E:  MOVF   17,F
4060:  BZ    414A
....................        { 
....................          if(vpcb[colap[0]].estado==1) 
4062:  MOVF   18,W
4064:  MULLW  11
4066:  MOVF   FF3,W
4068:  CLRF   xE6
406A:  MOVWF  xE5
406C:  MOVLW  0C
406E:  ADDWF  xE5,W
4070:  MOVWF  01
4072:  MOVLW  00
4074:  ADDWFC xE6,W
4076:  MOVWF  03
4078:  MOVF   01,W
407A:  ADDLW  60
407C:  MOVWF  FE9
407E:  MOVLW  00
4080:  ADDWFC 03,W
4082:  MOVWF  FEA
4084:  DECFSZ FEF,W
4086:  BRA    40E4
....................             {activar_timer(); 
4088:  CALL   07B0
....................              vpcb[colap[0]].estado=2; 
408C:  MOVF   18,W
408E:  MULLW  11
4090:  MOVF   FF3,W
4092:  CLRF   xE6
4094:  MOVWF  xE5
4096:  MOVLW  0C
4098:  ADDWF  xE5,W
409A:  MOVWF  01
409C:  MOVLW  00
409E:  ADDWFC xE6,W
40A0:  MOVWF  03
40A2:  MOVF   01,W
40A4:  ADDLW  60
40A6:  MOVWF  FE9
40A8:  MOVLW  00
40AA:  ADDWFC 03,W
40AC:  MOVWF  FEA
40AE:  MOVLW  02
40B0:  MOVWF  FEF
....................              goto_address(vpcb[colap[0]].di); 
40B2:  MOVF   18,W
40B4:  MULLW  11
40B6:  MOVF   FF3,W
40B8:  CLRF   xE6
40BA:  MOVWF  xE5
40BC:  MOVLW  60
40BE:  ADDWF  xE5,W
40C0:  MOVWF  FE9
40C2:  MOVLW  00
40C4:  ADDWFC xE6,W
40C6:  MOVWF  FEA
40C8:  MOVFF  FEF,E7
40CC:  MOVFF  FEC,E8
40D0:  MOVFF  FEC,E9
40D4:  MOVFF  FEC,EA
40D8:  MOVFF  E8,FFA
40DC:  MOVFF  E7,FE8
40E0:  MOVWF  FF9
....................             } 
40E2:  BRA    414A
....................          else 
....................             {wreg=vpcb[colap[0]].wreg; 
40E4:  MOVF   18,W
40E6:  MULLW  11
40E8:  MOVF   FF3,W
40EA:  CLRF   xE6
40EC:  MOVWF  xE5
40EE:  MOVLW  0D
40F0:  ADDWF  xE5,W
40F2:  MOVWF  01
40F4:  MOVLW  00
40F6:  ADDWFC xE6,W
40F8:  MOVWF  03
40FA:  MOVF   01,W
40FC:  ADDLW  60
40FE:  MOVWF  FE9
4100:  MOVLW  00
4102:  ADDWFC 03,W
4104:  MOVWF  FEA
4106:  MOVFF  FEF,FE8
....................              activar_timer(); 
410A:  CALL   07B0
....................              goto_address(vpcb[colap[0]].da); 
410E:  MOVF   18,W
4110:  MULLW  11
4112:  MOVF   FF3,W
4114:  CLRF   xE6
4116:  MOVWF  xE5
4118:  MOVLW  08
411A:  ADDWF  xE5,W
411C:  MOVWF  01
411E:  MOVLW  00
4120:  ADDWFC xE6,W
4122:  MOVWF  03
4124:  MOVF   01,W
4126:  ADDLW  60
4128:  MOVWF  FE9
412A:  MOVLW  00
412C:  ADDWFC 03,W
412E:  MOVWF  FEA
4130:  MOVFF  FEF,E5
4134:  MOVFF  FEC,E6
4138:  MOVFF  FEC,E7
413C:  MOVFF  FEC,E8
4140:  MOVFF  E6,FFA
4144:  MOVFF  E5,FE8
4148:  MOVWF  FF9
....................             } 
....................        } 
414A:  BRA    4000
....................    } 
414C:  RETURN 0
.................... } 
....................  
.................... void main(void) 
*
092A:  CLRF   FF8
092C:  BCF    FD0.7
092E:  BSF    07.7
0930:  BCF    FB8.3
0932:  MOVLW  40
0934:  MOVWF  FAF
0936:  MOVLW  A6
0938:  MOVWF  FAC
093A:  MOVLW  90
093C:  MOVWF  FAB
093E:  CLRF   17
0940:  CLRF   37
0942:  CLRF   36
0944:  CLRF   35
0946:  CLRF   34
0948:  CLRF   3B
094A:  CLRF   3A
094C:  CLRF   39
094E:  CLRF   38
0950:  MOVLW  FE
0952:  MOVWF  51
0954:  MOVLW  18
0956:  MOVWF  50
0958:  CLRF   52
095A:  CLRF   5D
095C:  BCF    5F.0
095E:  MOVF   FC1,W
0960:  ANDLW  C0
0962:  IORLW  0F
0964:  MOVWF  FC1
0966:  MOVLW  07
0968:  MOVWF  FB4
.................... { 
....................    printf("Esperando conexión..*"); 
096A:  MOVLW  BC
096C:  MOVWF  FF6
096E:  MOVLW  07
0970:  MOVWF  FF7
0972:  CLRF   16
0974:  BTFSC  FF2.7
0976:  BSF    16.7
0978:  BCF    FF2.7
097A:  RCALL  028E
097C:  BTFSC  16.7
097E:  BSF    FF2.7
....................     
....................    MCU_Init(); 
0980:  BRA    08E8
....................    #asm 
....................    call 0x4000 
0982:  CALL   4000,1
....................    #endasm 
.................... } 
....................  
0986:  SLEEP 

Configuration Fuses:
   Word  1: CC27   PLL12 CPUDIV1 USBDIV HS FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
